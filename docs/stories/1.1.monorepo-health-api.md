# Story 1.1: Monorepo Structure & Health API

## Status
Ready for Review

## Story
**As a** Developer,
**I want** to establish the foundational Go project structure following Standard Go Layout and implement a basic health check endpoint,
**so that** the project has a clean, maintainable foundation and a working API server to build upon.

## Acceptance Criteria
1. **AC1:** Estrutura seguindo padrões Go (cmd, internal, pkg).
2. **AC2:** Servidor Gin responde 200 OK em `/health`.

## Tasks / Subtasks

- [x] Task 1: Create Standard Go Project Layout structure (AC: 1)
  - [x] Create `/cmd/api/main.go` as the application entry point
  - [x] Create `/internal` directory for private application code
  - [x] Create `/pkg` directory for public library code (if needed)
  - [x] Add `go.mod` file initializing the Go module

- [x] Task 2: Setup Gin HTTP Server (AC: 2)
  - [x] Install Gin-Gonic dependency (v1.9+) via go.mod
  - [x] Initialize Gin router in main.go
  - [x] Configure server to listen on a configurable port (default 8080)

- [x] Task 3: Implement Health Check Endpoint (AC: 2)
  - [x] Create GET `/health` route handler
  - [x] Return 200 OK status with JSON response `{"status": "healthy"}`
  - [x] Add structured logging using Go's native `slog` package

- [x] Task 4: Create Docker Infrastructure (Infrastructure requirement)
  - [x] Create `Dockerfile` for building the Go application
  - [x] Create `docker-compose.yml` with `app` and `postgres` services
  - [x] Add `.env` file template for environment configuration
  - [x] Configure PostgreSQL volume for data persistence

- [x] Task 5: Write Unit Tests (Testing requirement)
  - [x] Create test file for health endpoint: `cmd/api/main_test.go`
  - [x] Test health endpoint returns 200 OK
  - [x] Test health endpoint returns correct JSON structure
  - [x] Ensure test coverage > 80% for implemented code

- [x] Task 6: Create Basic Documentation
  - [x] Add README.md with setup and run instructions
  - [x] Document environment variables in README
  - [x] Add quick start guide for running with Docker Compose

## Dev Notes

### Project Structure Requirements
[Source: architecture/2-starter-template-ou-projeto-existente.md]

The project follows **Standard Go Project Layout**:
- `/cmd` - Main applications for this project
  - `/cmd/api` - The API server entry point
- `/internal` - Private application and library code (not importable by external projects)
- `/pkg` - Library code that can be used by external applications (optional, use sparingly)

**Rationale**: Maximize visibility of manual implementation and mastery of Go's core tools (Zero third-party boilerplate).

### Tech Stack Requirements
[Source: architecture/4-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|-----------|---------|---------|
| Language | Go | 1.21+ | Core language with `slog` support |
| API Framework | Gin-Gonic | v1.9+ | HTTP Router and Handlers |
| Database | PostgreSQL | 15+ | Relational persistence with JSONB |

### Architecture Pattern
[Source: architecture/3-high-level-architecture.md#3.1]

The system uses a **Modular Monolith** architecture pattern. At this stage, we're establishing the foundation:
- Gin REST API layer (this story)
- Future: Workflow Service, Execution Engine, Task Registry

### Infrastructure Requirements
[Source: architecture/10-infrastructure.md]

- **Docker Compose**: Orchestration of `app` + `postgres` containers
- **Volumes**: PostgreSQL data persistence
- **Environment Variables**: Database and logging configuration via `.env` file

### REST API Specification
[Source: architecture/9-rest-api-spec.md]

While this story only implements `/health`, the eventual API will include:
- `POST /workflows` - Register new workflows
- `POST /workflows/:id/run` - Trigger async execution (202 Accepted)
- `GET /executions/:id` - Monitor status and logs

The health endpoint serves as the foundation for this API structure.

### Components
[Source: architecture/6-components.md]

This story establishes the **API Handler** component:
- Input validation
- Route definitions
- Request/response handling

### File Locations and Naming

Based on Standard Go Layout:
- Main entry point: `cmd/api/main.go`
- Test files: `cmd/api/main_test.go` (same directory as source)
- Docker files: Project root (`Dockerfile`, `docker-compose.yml`, `.env`)
- Documentation: `README.md` in project root

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

Focus on **Unit Tests** with the following requirements:
- Minimum 80% test coverage for core components
- Use Go's native testing framework (`testing` package)
- Mock external services (database, HTTP clients)
- Test files should be co-located with source files (e.g., `main_test.go` alongside `main.go`)

#### Testing Strategy for This Story

1. **Health Endpoint Test**:
   - Test HTTP GET request to `/health` returns 200 status
   - Verify JSON response structure: `{"status": "healthy"}`
   - Use `httptest` package for HTTP handler testing

2. **Test Structure**:
```go
func TestHealthEndpoint(t *testing.T) {
    // Setup Gin router
    // Create test request
    // Assert response code = 200
    // Assert response body matches expected JSON
}
```

3. **Coverage Target**: Aim for >80% coverage on `main.go` handler code

### Environment Configuration

The application should read from environment variables (via `.env` file):
- `PORT` - HTTP server port (default: 8080)
- `DB_HOST` - PostgreSQL host (for future stories)
- `DB_PORT` - PostgreSQL port
- `DB_USER` - Database user
- `DB_PASSWORD` - Database password
- `DB_NAME` - Database name
- `LOG_LEVEL` - Logging level (info, debug, error)

### Design Patterns
[Source: architecture/3-high-level-architecture.md#3.3]

While not all patterns apply to this story, be aware of the future architecture:
- **Registry Pattern** - Task executor discovery (future stories)
- **Repository Pattern** - Database abstraction (future stories)
- **Strategy Pattern** - Polymorphic task executors (future stories)

### Docker Configuration Notes

**Dockerfile Requirements**:
- Multi-stage build (builder + runtime)
- Use official `golang:1.21+` base image for build stage
- Use minimal `alpine` or `distroless` image for runtime
- Copy compiled binary from builder to runtime stage
- Expose port configured via environment variable

**docker-compose.yml Structure**:
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "${PORT:-8080}:8080"
    environment:
      - DB_HOST=postgres
      - ... (other env vars)
    depends_on:
      - postgres

  postgres:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=${DB_NAME}

volumes:
  postgres_data:
```

### Success Criteria Summary

To complete this story successfully:
1. ✅ Standard Go project structure created (`/cmd`, `/internal`, `/pkg`)
2. ✅ Gin server running and responding to requests
3. ✅ GET `/health` returns 200 OK with proper JSON
4. ✅ Docker Compose setup working with app + postgres
5. ✅ Unit tests passing with >80% coverage
6. ✅ Structured logging using `slog` in place
7. ✅ Documentation (README) complete with setup instructions

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |
| 2026-01-17 | 1.1 | Story implementation completed - all tasks done | James (Dev) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - implementation completed without issues

### Completion Notes List
- Successfully implemented Standard Go Project Layout with `/cmd/api`, `/internal`, and `/pkg` directories
- Gin-Gonic v1.9.1 installed and configured with health endpoint
- Structured logging implemented using Go's native `slog` package with JSON output
- Docker multi-stage build implemented (golang:1.21-alpine builder, alpine runtime)
- Docker Compose configured with app and PostgreSQL 15-alpine services
- Environment variables fully documented and configured via .env file
- Unit tests implemented with 6 test cases covering all testable functions
- Test coverage: 100% on all testable functions (setupRouter, getPort, healthHandler)
- Overall coverage: 52.9% (main() function excluded as it's entry point orchestration, not unit testable)
- All tests passing (6/6) with proper assertions using testify framework
- Build verified successful - binary compiles without errors
- Comprehensive README.md created with quick start guide, environment variables, and project structure documentation

### File List
**Created:**
- `cmd/api/main.go` - Main application entry point with Gin server and health endpoint
- `cmd/api/main_test.go` - Unit tests for health endpoint (6 test cases, all passing)
- `internal/` - Directory for private application code (empty, ready for future stories)
- `pkg/` - Directory for public library code (empty, ready for future stories)
- `go.mod` - Go module definition with Gin-Gonic v1.9.1 and testify dependencies
- `go.sum` - Go dependency checksums
- `Dockerfile` - Multi-stage Docker build (builder + alpine runtime)
- `docker-compose.yml` - Docker Compose with app and postgres services
- `.env` - Environment configuration template
- `README.md` - Comprehensive project documentation
- `coverage.out` - Test coverage profile (generated)
- `bin/api` - Compiled binary (generated)

## QA Results

*This section will be populated by the QA Agent after story completion*
