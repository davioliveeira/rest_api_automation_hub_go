# Story 1.1: Monorepo Structure & Health API

## Status
Approved

## Story
**As a** Developer,
**I want** to establish the foundational Go project structure following Standard Go Layout and implement a basic health check endpoint,
**so that** the project has a clean, maintainable foundation and a working API server to build upon.

## Acceptance Criteria
1. **AC1:** Estrutura seguindo padrões Go (cmd, internal, pkg).
2. **AC2:** Servidor Gin responde 200 OK em `/health`.

## Tasks / Subtasks

- [ ] Task 1: Create Standard Go Project Layout structure (AC: 1)
  - [ ] Create `/cmd/api/main.go` as the application entry point
  - [ ] Create `/internal` directory for private application code
  - [ ] Create `/pkg` directory for public library code (if needed)
  - [ ] Add `go.mod` file initializing the Go module

- [ ] Task 2: Setup Gin HTTP Server (AC: 2)
  - [ ] Install Gin-Gonic dependency (v1.9+) via go.mod
  - [ ] Initialize Gin router in main.go
  - [ ] Configure server to listen on a configurable port (default 8080)

- [ ] Task 3: Implement Health Check Endpoint (AC: 2)
  - [ ] Create GET `/health` route handler
  - [ ] Return 200 OK status with JSON response `{"status": "healthy"}`
  - [ ] Add structured logging using Go's native `slog` package

- [ ] Task 4: Create Docker Infrastructure (Infrastructure requirement)
  - [ ] Create `Dockerfile` for building the Go application
  - [ ] Create `docker-compose.yml` with `app` and `postgres` services
  - [ ] Add `.env` file template for environment configuration
  - [ ] Configure PostgreSQL volume for data persistence

- [ ] Task 5: Write Unit Tests (Testing requirement)
  - [ ] Create test file for health endpoint: `cmd/api/main_test.go`
  - [ ] Test health endpoint returns 200 OK
  - [ ] Test health endpoint returns correct JSON structure
  - [ ] Ensure test coverage > 80% for implemented code

- [ ] Task 6: Create Basic Documentation
  - [ ] Add README.md with setup and run instructions
  - [ ] Document environment variables in README
  - [ ] Add quick start guide for running with Docker Compose

## Dev Notes

### Project Structure Requirements
[Source: architecture/2-starter-template-ou-projeto-existente.md]

The project follows **Standard Go Project Layout**:
- `/cmd` - Main applications for this project
  - `/cmd/api` - The API server entry point
- `/internal` - Private application and library code (not importable by external projects)
- `/pkg` - Library code that can be used by external applications (optional, use sparingly)

**Rationale**: Maximize visibility of manual implementation and mastery of Go's core tools (Zero third-party boilerplate).

### Tech Stack Requirements
[Source: architecture/4-tech-stack.md]

| Component | Technology | Version | Purpose |
|-----------|-----------|---------|---------|
| Language | Go | 1.21+ | Core language with `slog` support |
| API Framework | Gin-Gonic | v1.9+ | HTTP Router and Handlers |
| Database | PostgreSQL | 15+ | Relational persistence with JSONB |

### Architecture Pattern
[Source: architecture/3-high-level-architecture.md#3.1]

The system uses a **Modular Monolith** architecture pattern. At this stage, we're establishing the foundation:
- Gin REST API layer (this story)
- Future: Workflow Service, Execution Engine, Task Registry

### Infrastructure Requirements
[Source: architecture/10-infrastructure.md]

- **Docker Compose**: Orchestration of `app` + `postgres` containers
- **Volumes**: PostgreSQL data persistence
- **Environment Variables**: Database and logging configuration via `.env` file

### REST API Specification
[Source: architecture/9-rest-api-spec.md]

While this story only implements `/health`, the eventual API will include:
- `POST /workflows` - Register new workflows
- `POST /workflows/:id/run` - Trigger async execution (202 Accepted)
- `GET /executions/:id` - Monitor status and logs

The health endpoint serves as the foundation for this API structure.

### Components
[Source: architecture/6-components.md]

This story establishes the **API Handler** component:
- Input validation
- Route definitions
- Request/response handling

### File Locations and Naming

Based on Standard Go Layout:
- Main entry point: `cmd/api/main.go`
- Test files: `cmd/api/main_test.go` (same directory as source)
- Docker files: Project root (`Dockerfile`, `docker-compose.yml`, `.env`)
- Documentation: `README.md` in project root

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

Focus on **Unit Tests** with the following requirements:
- Minimum 80% test coverage for core components
- Use Go's native testing framework (`testing` package)
- Mock external services (database, HTTP clients)
- Test files should be co-located with source files (e.g., `main_test.go` alongside `main.go`)

#### Testing Strategy for This Story

1. **Health Endpoint Test**:
   - Test HTTP GET request to `/health` returns 200 status
   - Verify JSON response structure: `{"status": "healthy"}`
   - Use `httptest` package for HTTP handler testing

2. **Test Structure**:
```go
func TestHealthEndpoint(t *testing.T) {
    // Setup Gin router
    // Create test request
    // Assert response code = 200
    // Assert response body matches expected JSON
}
```

3. **Coverage Target**: Aim for >80% coverage on `main.go` handler code

### Environment Configuration

The application should read from environment variables (via `.env` file):
- `PORT` - HTTP server port (default: 8080)
- `DB_HOST` - PostgreSQL host (for future stories)
- `DB_PORT` - PostgreSQL port
- `DB_USER` - Database user
- `DB_PASSWORD` - Database password
- `DB_NAME` - Database name
- `LOG_LEVEL` - Logging level (info, debug, error)

### Design Patterns
[Source: architecture/3-high-level-architecture.md#3.3]

While not all patterns apply to this story, be aware of the future architecture:
- **Registry Pattern** - Task executor discovery (future stories)
- **Repository Pattern** - Database abstraction (future stories)
- **Strategy Pattern** - Polymorphic task executors (future stories)

### Docker Configuration Notes

**Dockerfile Requirements**:
- Multi-stage build (builder + runtime)
- Use official `golang:1.21+` base image for build stage
- Use minimal `alpine` or `distroless` image for runtime
- Copy compiled binary from builder to runtime stage
- Expose port configured via environment variable

**docker-compose.yml Structure**:
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "${PORT:-8080}:8080"
    environment:
      - DB_HOST=postgres
      - ... (other env vars)
    depends_on:
      - postgres

  postgres:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=${DB_NAME}

volumes:
  postgres_data:
```

### Success Criteria Summary

To complete this story successfully:
1. ✅ Standard Go project structure created (`/cmd`, `/internal`, `/pkg`)
2. ✅ Gin server running and responding to requests
3. ✅ GET `/health` returns 200 OK with proper JSON
4. ✅ Docker Compose setup working with app + postgres
5. ✅ Unit tests passing with >80% coverage
6. ✅ Structured logging using `slog` in place
7. ✅ Documentation (README) complete with setup instructions

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by the QA Agent after story completion*
