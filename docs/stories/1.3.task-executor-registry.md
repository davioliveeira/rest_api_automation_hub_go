# Story 1.3: TaskExecutor Contract & Registry

## Status
Draft

## Story
**As a** Developer,
**I want** to define the TaskExecutor interface and implement a dynamic task registry system,
**so that** the execution engine can discover and invoke different task types in a decoupled, extensible manner.

## Acceptance Criteria
1. **AC1:** Interface `TaskExecutor` define o retorno `TaskResult` (Status, Output, Error).
2. **AC2:** Sistema de registo dinâmico de nós por tipo.

## Tasks / Subtasks

- [ ] Task 1: Define TaskExecutor interface (AC: 1)
  - [ ] Create `internal/engine/executor.go` file
  - [ ] Define `TaskExecutor` interface with `Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult` method
  - [ ] Ensure TaskResult struct from Story 1.2 (types.go) includes Status, Output, Error fields
  - [ ] Add comprehensive documentation comments explaining interface contract

- [ ] Task 2: Implement Task Registry (AC: 2)
  - [ ] Create `internal/engine/registry.go` file
  - [ ] Define `Registry` struct with internal map: `map[string]TaskExecutor`
  - [ ] Implement `NewRegistry()` constructor returning initialized registry
  - [ ] Implement `Register(taskType string, executor TaskExecutor)` method
  - [ ] Implement `Get(taskType string) (TaskExecutor, error)` method
  - [ ] Add thread-safe access using sync.RWMutex
  - [ ] Return descriptive error when task type not found

- [ ] Task 3: Create Mock/Test Task Executor (for testing)
  - [ ] Create `internal/engine/mock_executor.go` file
  - [ ] Implement `MockExecutor` struct implementing TaskExecutor interface
  - [ ] MockExecutor.Execute() returns success with configurable output
  - [ ] Add support for simulating task failures for testing
  - [ ] Document that this is for testing purposes only

- [ ] Task 4: Integrate Registry into Engine (AC: 1, 2)
  - [ ] Update `Engine` struct in `engine.go` to include Registry field
  - [ ] Modify `NewEngine()` to accept or create a Registry instance
  - [ ] Update `Execute()` method to:
    - [ ] Lookup task executor from registry using task.Type
    - [ ] Invoke executor.Execute() passing ExecutionContext and task.Config
    - [ ] Handle TaskResult (log status, update context with output)
    - [ ] Handle registry lookup errors (task type not registered)
  - [ ] Replace placeholder logic from Story 1.2 with actual executor calls
  - [ ] Add structured logging for task execution start/end

- [ ] Task 5: Write comprehensive unit tests (Testing requirement)
  - [ ] Create `internal/engine/executor_test.go`
    - [ ] Test MockExecutor implements TaskExecutor interface
    - [ ] Test MockExecutor returns expected results
  - [ ] Create `internal/engine/registry_test.go`
    - [ ] Test Register() adds executors successfully
    - [ ] Test Get() retrieves registered executors
    - [ ] Test Get() returns error for unregistered types
    - [ ] Test concurrent access safety (goroutines)
  - [ ] Update `internal/engine/engine_test.go`
    - [ ] Test engine with registered mock executor
    - [ ] Test workflow execution calls correct executor
    - [ ] Test error handling when task type not registered
    - [ ] Test TaskResult output is stored in ExecutionContext
    - [ ] Test multiple tasks with different types execute correctly
  - [ ] Ensure >80% test coverage across all modified/new files

- [ ] Task 6: Integration preparation for Epic 2
  - [ ] Document how Epic 2 stories will register real task executors (HTTP, Parser, DB, Transform)
  - [ ] Ensure registry can be accessed globally or passed to initialization functions
  - [ ] Add code comments showing example registration pattern

## Dev Notes

### Previous Story Context

**From Story 1.1:**
- Standard Go Project Layout established (`/cmd`, `/internal`, `/pkg`)
- Gin API server running at `cmd/api/main.go` with `/health` endpoint
- Docker Compose infrastructure ready (app + postgres)
- Testing standards: 80% coverage, Go native testing framework

**From Story 1.2 - CRITICAL for Story 1.3:**
- `ExecutionContext` implemented with thread-safe Set/Get operations
- `Engine` struct with `Execute(workflow WorkflowDefinition)` method
- Sequential task loop infrastructure in place
- `WorkflowDefinition`, `Task`, and `TaskResult` structs defined in `types.go`
- **Placeholder logic in engine.go waiting to be replaced:** Story 1.2 included placeholder comments like "// Placeholder: Story 1.3 will add actual task execution"
- **Integration notes from Story 1.2 explicitly stated:**
  - "Engine needs to accept TaskExecutor interface (to be defined in 1.3)"
  - "Registry pattern will be introduced for task type lookup"
  - "Current placeholder logic will be replaced with actual executor calls"

**Key Story 1.2 Code to Update:**

From Story 1.2's `engine.go`:
```go
func (e *Engine) Execute(workflow WorkflowDefinition) error {
    slog.Info("Starting workflow execution", "workflow", workflow.Name)

    for i, task := range workflow.Tasks {
        slog.Info("Processing task", "index", i, "id", task.ID, "type", task.Type)

        // Placeholder: Story 1.3 will add actual task execution
        // For now, just demonstrate sequential processing

        // Update context with task output (simulated)
        e.context.Set(task.ID+"_result", "placeholder")
    }

    slog.Info("Workflow execution completed", "workflow", workflow.Name)
    return nil
}
```

**Story 1.3 must replace the placeholder section with:**
```go
// Lookup executor from registry
executor, err := e.registry.Get(task.Type)
if err != nil {
    slog.Error("Task executor not found", "type", task.Type, "error", err)
    return fmt.Errorf("task executor not found for type '%s': %w", task.Type, err)
}

// Execute task
result := executor.Execute(e.context, task.Config)

// Handle result
if result.Status == "success" {
    slog.Info("Task completed successfully", "id", task.ID)
    e.context.Set(task.ID+"_result", result.Output)
} else {
    slog.Error("Task failed", "id", task.ID, "error", result.Error)
    return fmt.Errorf("task %s failed: %s", task.ID, result.Error)
}
```

### Acceptance Criteria Breakdown

**AC1: Interface `TaskExecutor` define o retorno `TaskResult` (Status, Output, Error)**

This means:
- Define a Go interface named `TaskExecutor`
- The interface must have an `Execute` method
- The method must return `TaskResult` type (already defined in Story 1.2)
- TaskResult must contain: Status (string), Output (interface{}), Error (string)

**AC2: Sistema de registo dinâmico de nós por tipo**

This means:
- Create a Registry system that maps task types (strings) to TaskExecutor implementations
- Support dynamic registration at runtime (Register method)
- Support lookup of executors by type (Get method)
- Thread-safe operations (multiple goroutines might register or lookup)
- Decouples engine from knowing specific task implementations

### Architecture - Design Patterns
[Source: architecture/3-high-level-architecture.md#3.3]

**Registry Pattern:**
- "Desacoplamento de tipos de tarefas do motor central"
- Central registry acts as a service locator for task executors
- Engine doesn't know about specific task implementations
- New task types can be added without modifying engine code

**Strategy Pattern:**
- "Implementação polimórfica dos executores de nós"
- Different task executors implement the same TaskExecutor interface
- Engine treats all executors uniformly through the interface
- Executors encapsulate task-specific logic

**Benefits:**
- **Extensibility:** Adding a new task type requires only implementing TaskExecutor and registering it
- **Testability:** Mock executors can be registered for testing
- **Separation of Concerns:** Engine focuses on orchestration, executors focus on task logic
- **Maintainability:** Task implementations are isolated in separate files/packages

### Architecture - Components
[Source: architecture/6-components.md]

**Task Executors:**
- "Implementações específicas do contrato `TaskExecutor`"
- Each executor handles one task type (e.g., http_request, html_parser, database_query)
- Executors receive ExecutionContext to read/write shared data
- Executors receive task-specific configuration via config map

**Execution Engine:**
- "Loop de orquestração e lógica de retry"
- Story 1.3 completes the orchestration loop by adding executor invocation
- (Retry logic will be added in future stories per FR8)

### Architecture - High Level Project Diagram
[Source: architecture/3-high-level-architecture.md#3.2]

The architecture diagram shows this relationship:
```
Engine --> Registry[Task Registry]
Registry --> T1[HTTP Task]
Registry --> T2[HTML Parser Task]
Registry --> T3[DB Task]
Registry --> T4[Transform Task]
```

**Story 1.3 implements:**
- The Registry component
- The TaskExecutor interface that T1-T4 will implement
- The connection from Engine to Registry

**Epic 2 will implement:**
- T1 (HTTP Task) - Story 2.1
- T2 (HTML Parser Task) - Story 2.3
- T3 (Transform Task) - Story 2.2
- (DB Task will come in Epic 3)

### Core Workflows - Happy Path Execution
[Source: architecture/8-core-workflows.md#8.1]

The sequence diagram shows:
```
E->>X: Run Task
X-->>E: TaskResult(Output)
E->>CTX: Update Context
```

**Story 1.3 implements this flow:**
1. Engine lookups executor (X) from Registry
2. Engine calls X.Execute(context, config)
3. Executor returns TaskResult
4. Engine updates ExecutionContext with result output

### Tech Stack
[Source: architecture/4-tech-stack.md]

- **Language:** Go 1.21+ (use interfaces for polymorphism)
- **Concurrency:** sync.RWMutex for thread-safe registry operations
- **Logging:** Native `log/slog` for structured logging
- **Testing:** Native `testing` package with mock executor

### File Locations and Structure

Extending the `/internal/engine/` package from Story 1.2:

```
internal/engine/
├── context.go          - ExecutionContext (Story 1.2)
├── context_test.go     - ExecutionContext tests (Story 1.2)
├── engine.go           - Engine orchestration (Story 1.2, updated in 1.3)
├── engine_test.go      - Engine tests (Story 1.2, updated in 1.3)
├── types.go            - Workflow, Task, TaskResult structs (Story 1.2)
├── executor.go         - TaskExecutor interface (NEW in Story 1.3)
├── executor_test.go    - TaskExecutor tests (NEW in Story 1.3)
├── registry.go         - Registry implementation (NEW in Story 1.3)
├── registry_test.go    - Registry tests (NEW in Story 1.3)
└── mock_executor.go    - Mock executor for testing (NEW in Story 1.3)
```

**Package name:** `engine`

**Import path:** `github.com/[username]/goautomation-hub/internal/engine`

### Code Structure Guidance

**executor.go structure:**
```go
package engine

// TaskExecutor defines the contract for all task implementations.
// Each task type (http_request, html_parser, etc.) must implement this interface.
type TaskExecutor interface {
    // Execute runs the task with the given context and configuration.
    // The ExecutionContext allows reading data from previous tasks and storing output.
    // The config map contains task-specific configuration from the workflow JSON.
    // Returns a TaskResult indicating success/failure, output data, and any error message.
    Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult
}
```

**registry.go structure:**
```go
package engine

import (
    "fmt"
    "sync"
)

// Registry maintains a mapping of task types to their executor implementations.
// It provides thread-safe registration and lookup of task executors.
type Registry struct {
    mu        sync.RWMutex
    executors map[string]TaskExecutor
}

// NewRegistry creates and initializes a new task registry.
func NewRegistry() *Registry {
    return &Registry{
        executors: make(map[string]TaskExecutor),
    }
}

// Register adds a task executor for the given task type.
// If a task type is already registered, it will be overwritten.
func (r *Registry) Register(taskType string, executor TaskExecutor) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.executors[taskType] = executor
}

// Get retrieves the task executor for the given task type.
// Returns an error if the task type is not registered.
func (r *Registry) Get(taskType string) (TaskExecutor, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    executor, exists := r.executors[taskType]
    if !exists {
        return nil, fmt.Errorf("no executor registered for task type: %s", taskType)
    }
    return executor, nil
}

// List returns all registered task types (useful for debugging/diagnostics)
func (r *Registry) List() []string {
    r.mu.RLock()
    defer r.mu.RUnlock()

    types := make([]string, 0, len(r.executors))
    for taskType := range r.executors {
        types = append(types, taskType)
    }
    return types
}
```

**mock_executor.go structure:**
```go
package engine

// MockExecutor is a test implementation of TaskExecutor.
// It can be configured to return success or failure for testing purposes.
type MockExecutor struct {
    ShouldFail bool
    Output     interface{}
    ErrorMsg   string
}

// Execute implements the TaskExecutor interface for testing.
func (m *MockExecutor) Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult {
    if m.ShouldFail {
        return TaskResult{
            Status: "failed",
            Output: nil,
            Error:  m.ErrorMsg,
        }
    }

    // Simulate successful task execution
    output := m.Output
    if output == nil {
        output = map[string]interface{}{"mock": "result"}
    }

    return TaskResult{
        Status: "success",
        Output: output,
        Error:  "",
    }
}
```

**Updated engine.go with Registry integration:**
```go
package engine

import (
    "fmt"
    "log/slog"
)

type Engine struct {
    context  *ExecutionContext
    registry *Registry
}

// NewEngine creates a new execution engine with an initialized registry.
func NewEngine(registry *Registry) *Engine {
    if registry == nil {
        registry = NewRegistry()
    }
    return &Engine{
        context:  NewExecutionContext(),
        registry: registry,
    }
}

func (e *Engine) Execute(workflow WorkflowDefinition) error {
    slog.Info("Starting workflow execution", "workflow", workflow.Name, "task_count", len(workflow.Tasks))

    for i, task := range workflow.Tasks {
        slog.Info("Processing task", "index", i, "id", task.ID, "type", task.Type)

        // Lookup executor from registry
        executor, err := e.registry.Get(task.Type)
        if err != nil {
            slog.Error("Task executor not found", "type", task.Type, "error", err)
            return fmt.Errorf("task executor not found for type '%s': %w", task.Type, err)
        }

        // Execute task
        result := executor.Execute(e.context, task.Config)

        // Handle result
        if result.Status == "success" {
            slog.Info("Task completed successfully", "id", task.ID, "type", task.Type)
            // Store result in context for subsequent tasks
            e.context.Set(task.ID+"_result", result.Output)
        } else {
            slog.Error("Task failed", "id", task.ID, "type", task.Type, "error", result.Error)
            return fmt.Errorf("task %s failed: %s", task.ID, result.Error)
        }
    }

    slog.Info("Workflow execution completed successfully", "workflow", workflow.Name)
    return nil
}
```

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Table-driven tests for multiple scenarios
- Mock external dependencies using MockExecutor
- Co-locate test files with source files

#### Testing Strategy for Story 1.3

**executor_test.go tests:**

1. **Test MockExecutor Implementation:**
```go
func TestMockExecutor_Success(t *testing.T) {
    executor := &MockExecutor{
        ShouldFail: false,
        Output:     map[string]interface{}{"data": "test"},
    }

    ctx := NewExecutionContext()
    config := map[string]interface{}{}

    result := executor.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.NotNil(t, result.Output)
    assert.Empty(t, result.Error)
}

func TestMockExecutor_Failure(t *testing.T) {
    executor := &MockExecutor{
        ShouldFail: true,
        ErrorMsg:   "mock error",
    }

    ctx := NewExecutionContext()
    result := executor.Execute(ctx, map[string]interface{}{})

    assert.Equal(t, "failed", result.Status)
    assert.Equal(t, "mock error", result.Error)
}
```

**registry_test.go tests:**

1. **Test Registration:**
```go
func TestRegistry_Register(t *testing.T) {
    registry := NewRegistry()
    executor := &MockExecutor{}

    registry.Register("test_task", executor)

    retrieved, err := registry.Get("test_task")
    assert.NoError(t, err)
    assert.NotNil(t, retrieved)
}
```

2. **Test Get Non-Existent Type:**
```go
func TestRegistry_GetNotFound(t *testing.T) {
    registry := NewRegistry()

    executor, err := registry.Get("nonexistent")
    assert.Error(t, err)
    assert.Nil(t, executor)
    assert.Contains(t, err.Error(), "no executor registered")
}
```

3. **Test Concurrent Access:**
```go
func TestRegistry_ConcurrentAccess(t *testing.T) {
    registry := NewRegistry()
    var wg sync.WaitGroup

    // Multiple goroutines registering executors
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            executor := &MockExecutor{}
            registry.Register(fmt.Sprintf("task%d", id), executor)
        }(i)
    }

    // Multiple goroutines reading
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            _, _ = registry.Get(fmt.Sprintf("task%d", id))
        }(i)
    }

    wg.Wait()
    // No race conditions should occur
}
```

4. **Test List Functionality:**
```go
func TestRegistry_List(t *testing.T) {
    registry := NewRegistry()

    registry.Register("task1", &MockExecutor{})
    registry.Register("task2", &MockExecutor{})
    registry.Register("task3", &MockExecutor{})

    types := registry.List()
    assert.Len(t, types, 3)
    assert.Contains(t, types, "task1")
    assert.Contains(t, types, "task2")
    assert.Contains(t, types, "task3")
}
```

**engine_test.go updates:**

1. **Test Engine with Registry:**
```go
func TestEngine_WithMockExecutor(t *testing.T) {
    registry := NewRegistry()
    mockExecutor := &MockExecutor{
        ShouldFail: false,
        Output:     map[string]interface{}{"result": "success"},
    }
    registry.Register("mock_task", mockExecutor)

    engine := NewEngine(registry)

    workflow := WorkflowDefinition{
        Name: "test-workflow",
        Tasks: []Task{
            {ID: "task1", Type: "mock_task", Config: map[string]interface{}{}},
        },
    }

    err := engine.Execute(workflow)
    assert.NoError(t, err)

    // Verify result was stored in context
    result, exists := engine.context.Get("task1_result")
    assert.True(t, exists)
    assert.NotNil(t, result)
}
```

2. **Test Unregistered Task Type:**
```go
func TestEngine_UnregisteredTaskType(t *testing.T) {
    registry := NewRegistry()
    engine := NewEngine(registry)

    workflow := WorkflowDefinition{
        Name: "test-workflow",
        Tasks: []Task{
            {ID: "task1", Type: "unknown_type", Config: map[string]interface{}{}},
        },
    }

    err := engine.Execute(workflow)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "task executor not found")
}
```

3. **Test Task Failure Propagation:**
```go
func TestEngine_TaskFailure(t *testing.T) {
    registry := NewRegistry()
    mockExecutor := &MockExecutor{
        ShouldFail: true,
        ErrorMsg:   "intentional failure",
    }
    registry.Register("failing_task", mockExecutor)

    engine := NewEngine(registry)

    workflow := WorkflowDefinition{
        Name: "test-workflow",
        Tasks: []Task{
            {ID: "task1", Type: "failing_task", Config: map[string]interface{}{}},
        },
    }

    err := engine.Execute(workflow)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "intentional failure")
}
```

4. **Test Multiple Tasks with Context Sharing:**
```go
func TestEngine_MultipleTasksContextSharing(t *testing.T) {
    registry := NewRegistry()

    // First executor sets data in context
    executor1 := &MockExecutor{Output: map[string]interface{}{"step1": "data"}}
    registry.Register("task_type_1", executor1)

    // Second executor can read from context
    executor2 := &MockExecutor{Output: map[string]interface{}{"step2": "more data"}}
    registry.Register("task_type_2", executor2)

    engine := NewEngine(registry)

    workflow := WorkflowDefinition{
        Name: "multi-task-workflow",
        Tasks: []Task{
            {ID: "task1", Type: "task_type_1", Config: map[string]interface{}{}},
            {ID: "task2", Type: "task_type_2", Config: map[string]interface{}{}},
        },
    }

    err := engine.Execute(workflow)
    assert.NoError(t, err)

    // Verify both results are in context
    result1, exists1 := engine.context.Get("task1_result")
    assert.True(t, exists1)
    assert.NotNil(t, result1)

    result2, exists2 := engine.context.Get("task2_result")
    assert.True(t, exists2)
    assert.NotNil(t, result2)
}
```

**Coverage Target:**
- TaskExecutor interface: 100% (through MockExecutor)
- Registry: >90% (all operations + concurrency)
- Engine updates: >85% (happy path + error cases)
- Overall: >80%

#### Running Tests

```bash
# Run all engine tests
go test ./internal/engine/... -v

# Run with race detection (important for Registry)
go test ./internal/engine/... -race

# Run with coverage
go test ./internal/engine/... -cover -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

### Integration with Future Stories

**For Epic 2 Stories (Task Node Implementations):**

Each Epic 2 story will:
1. Create a new file in `/internal/tasks/` (e.g., `http_task.go`)
2. Implement the TaskExecutor interface
3. Register the executor with the global/shared registry

Example registration pattern (documented in code comments):
```go
// In cmd/api/main.go or initialization function:
func initializeTaskRegistry(registry *engine.Registry) {
    // Epic 2 stories will add these registrations:
    // Story 2.1: registry.Register("http_request", tasks.NewHTTPTask())
    // Story 2.2: registry.Register("transform", tasks.NewTransformTask())
    // Story 2.3: registry.Register("html_parser", tasks.NewHTMLParserTask())
}
```

**Global Registry Pattern:**

To make registry accessible across the application:
```go
// In cmd/api/main.go:
var globalRegistry *engine.Registry

func main() {
    globalRegistry = engine.NewRegistry()
    initializeTaskRegistry(globalRegistry)

    engine := engine.NewEngine(globalRegistry)
    // ... rest of initialization
}
```

### Success Criteria Summary

To complete this story successfully:
1. ✅ TaskExecutor interface defined with Execute method returning TaskResult
2. ✅ Registry struct implemented with Register/Get methods
3. ✅ Registry is thread-safe (uses RWMutex, verified by tests)
4. ✅ MockExecutor implements TaskExecutor for testing
5. ✅ Engine updated to use Registry for task lookup
6. ✅ Engine calls executor.Execute() and handles TaskResult
7. ✅ Task output stored in ExecutionContext (accessible by subsequent tasks)
8. ✅ Error handling for unregistered task types
9. ✅ Unit tests passing with >80% coverage
10. ✅ Placeholder logic from Story 1.2 replaced with actual execution
11. ✅ Documentation/comments for Epic 2 integration pattern

### Error Handling

**Registry Errors:**
- Return descriptive error when task type not registered
- Log error with structured logging (slog)

**Execution Errors:**
- If registry.Get() fails, log error and return immediately
- If task execution fails (result.Status == "failed"), log error and return
- Don't panic - always return descriptive errors

**Future Enhancement (not in this story):**
- Retry logic per FR8 will be added in future stories
- For now, first failure stops execution

### Performance Considerations
[Source: prd/requirements.md - NFR4]

- Registry lookup must be fast (<50ms overhead per task)
- Use RWMutex for optimal read performance (many lookups, few registrations)
- Avoid copying executor instances - store pointers
- Keep registry operations simple and direct

### Design Notes

**Why Registry Pattern?**
1. **Decoupling:** Engine doesn't know about specific task implementations
2. **Extensibility:** New task types added without engine changes
3. **Testability:** Easy to inject mock executors
4. **Single Responsibility:** Engine orchestrates, executors implement logic

**Why Interface?**
1. **Polymorphism:** Treat all task types uniformly
2. **Flexibility:** Multiple implementations of same interface
3. **Mocking:** Easy to create test doubles
4. **Go Idioms:** Interfaces are the Go way for abstraction

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by the QA Agent after story completion*
