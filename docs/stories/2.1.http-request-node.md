# Story 2.1: HTTP Request Node

## Status
Draft

## Story
**As a** Workflow Designer,
**I want** an HTTP request task node that supports GET/POST methods with dynamic headers and body interpolation,
**so that** workflows can fetch data from external APIs and store responses in the execution context for subsequent tasks.

## Acceptance Criteria
1. **AC1:** Suporte a métodos HTTP, headers dinâmicos e captura de resposta para o contexto.

## Tasks / Subtasks

- [ ] Task 1: Create tasks package and HTTP task structure (AC: 1)
  - [ ] Create `internal/tasks/` directory
  - [ ] Create `internal/tasks/http_task.go` file
  - [ ] Define `HTTPTask` struct implementing `TaskExecutor` interface
  - [ ] Add package documentation explaining task implementations

- [ ] Task 2: Implement HTTP request configuration (AC: 1)
  - [ ] Define configuration structure for HTTP requests
  - [ ] Support `method` field (GET, POST, PUT, DELETE, PATCH)
  - [ ] Support `url` field (target URL)
  - [ ] Support `headers` field (map of header key-value pairs)
  - [ ] Support `body` field (request payload for POST/PUT/PATCH)
  - [ ] Support `timeout` field (optional, default 30s)

- [ ] Task 3: Implement body interpolation from ExecutionContext (AC: 1)
  - [ ] Parse body string for template variables (e.g., `{{context.key}}`)
  - [ ] Use Go's `text/template` for variable interpolation
  - [ ] Replace template variables with values from ExecutionContext
  - [ ] Handle missing context keys gracefully (error or empty string)
  - [ ] Support nested JSON body structures

- [ ] Task 4: Implement Execute method (AC: 1)
  - [ ] Validate configuration (required fields: method, url)
  - [ ] Apply body interpolation if body is provided
  - [ ] Build HTTP request with method, URL, headers, and body
  - [ ] Set request timeout (default 30s or configured value)
  - [ ] Execute HTTP request using Go's `net/http` client
  - [ ] Read response body
  - [ ] Parse JSON response (if Content-Type is application/json)
  - [ ] Return TaskResult with response data

- [ ] Task 5: Implement error handling (AC: 1)
  - [ ] Handle connection errors (timeout, DNS failure, etc.)
  - [ ] Handle HTTP error status codes (4xx, 5xx)
  - [ ] Return descriptive error messages in TaskResult.Error
  - [ ] Log errors using `slog`
  - [ ] Handle invalid configuration errors

- [ ] Task 6: Store response in ExecutionContext (AC: 1)
  - [ ] Return response body in TaskResult.Output
  - [ ] Include response status code in output
  - [ ] Include response headers in output
  - [ ] Engine will store TaskResult.Output in context (per Story 1.3)

- [ ] Task 7: Register HTTP task with Registry
  - [ ] Create initialization function `RegisterHTTPTask(registry *engine.Registry)`
  - [ ] Register with task type name "http_request"
  - [ ] Update main.go or initialization code to call registration
  - [ ] Document registration in code comments

- [ ] Task 8: Write comprehensive unit tests (Testing requirement)
  - [ ] Create `internal/tasks/http_task_test.go`
  - [ ] Test successful GET request
  - [ ] Test successful POST request with body
  - [ ] Test request with custom headers
  - [ ] Test body interpolation from context
  - [ ] Test connection timeout
  - [ ] Test HTTP error status handling (404, 500)
  - [ ] Test invalid configuration errors
  - [ ] Use httptest for mocking HTTP servers
  - [ ] Ensure >80% test coverage

- [ ] Task 9: Integration test with Engine
  - [ ] Create test workflow with http_request task
  - [ ] Verify task executes and stores response in context
  - [ ] Verify subsequent tasks can access HTTP response data
  - [ ] Test end-to-end workflow execution

## Dev Notes

### Epic 1 Foundation Context

**Story 1.1 established:**
- Standard Go Project Layout (`/cmd`, `/internal`, `/pkg`)
- Gin API server at `cmd/api/main.go`
- Docker Compose infrastructure
- Health endpoint demonstrating API server functionality

**Story 1.2 established:**
- `ExecutionContext` with thread-safe Get/Set methods
- Engine's Execute() method processing tasks sequentially
- `WorkflowDefinition`, `Task`, and `TaskResult` structs
- Context allows sharing data between tasks

**Story 1.3 established - CRITICAL for Story 2.1:**
- `TaskExecutor` interface with Execute() method
- `Registry` system for registering task implementations
- Engine integration: looks up executors from registry and invokes them
- `TaskResult` struct with Status, Output, Error fields
- **Registration pattern documented:**
  ```go
  // Story 2.1 will add:
  registry.Register("http_request", tasks.NewHTTPTask())
  ```

**Story 2.1 is the first concrete TaskExecutor implementation!**

### TaskExecutor Interface Contract
[Source: Story 1.3 - internal/engine/executor.go]

```go
type TaskExecutor interface {
    Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult
}
```

**Requirements:**
- Implement Execute method
- Accept ExecutionContext (for reading/writing shared data)
- Accept config map (task-specific configuration from workflow JSON)
- Return TaskResult with Status ("success" or "failed"), Output, and Error

### Functional Requirement FR4
[Source: prd/requirements.md - FR4]

**FR4:** "Implementar nó `http_request` com suporte a GET/POST, headers e interpolação de corpo."

**Breakdown:**
1. **HTTP Methods:** Support at minimum GET and POST (consider PUT, DELETE, PATCH for completeness)
2. **Headers:** Dynamic headers specified in configuration
3. **Body Interpolation:** Replace template variables in request body with ExecutionContext values

### Configuration Structure

The workflow JSON will provide configuration like this:

```json
{
  "id": "fetch_data",
  "type": "http_request",
  "config": {
    "method": "POST",
    "url": "https://api.example.com/data",
    "headers": {
      "Content-Type": "application/json",
      "Authorization": "Bearer {{context.auth_token}}"
    },
    "body": "{\"query\": \"{{context.search_term}}\"}",
    "timeout": 30
  }
}
```

**Configuration Fields:**
- `method` (string, required): HTTP method (GET, POST, PUT, DELETE, PATCH)
- `url` (string, required): Target URL
- `headers` (map, optional): HTTP headers as key-value pairs
- `body` (string, optional): Request body (for POST/PUT/PATCH)
- `timeout` (int, optional): Request timeout in seconds (default: 30)

### Body Interpolation Details

Use Go's `text/template` package (per architecture/4-tech-stack.md):

**Template Syntax:**
- `{{context.key}}` - Replace with value from ExecutionContext

**Implementation Approach:**
```go
import "text/template"

func (h *HTTPTask) interpolateBody(body string, ctx *engine.ExecutionContext) (string, error) {
    tmpl, err := template.New("body").Parse(body)
    if err != nil {
        return "", fmt.Errorf("failed to parse body template: %w", err)
    }

    // Get all context data
    contextData := ctx.GetAll()

    // Prepare template data
    data := map[string]interface{}{
        "context": contextData,
    }

    var buf bytes.Buffer
    if err := tmpl.Execute(&buf, data); err != nil {
        return "", fmt.Errorf("failed to execute body template: %w", err)
    }

    return buf.String(), nil
}
```

**Example:**
- Body template: `"{\"query\": \"{{context.search_term}}\"}"`
- Context has: `{"search_term": "golang"}`
- Result: `"{\"query\": \"golang\"}"`

### HTTP Request Implementation

**Using Go's net/http:**

```go
import (
    "bytes"
    "context"
    "encoding/json"
    "io"
    "net/http"
    "time"
)

func (h *HTTPTask) executeRequest(method, url string, headers map[string]string, body string, timeout int) (map[string]interface{}, error) {
    // Create request
    var reqBody io.Reader
    if body != "" {
        reqBody = bytes.NewBufferString(body)
    }

    req, err := http.NewRequest(method, url, reqBody)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }

    // Set headers
    for key, value := range headers {
        req.Header.Set(key, value)
    }

    // Create client with timeout
    client := &http.Client{
        Timeout: time.Duration(timeout) * time.Second,
    }

    // Execute request
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    // Read response body
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }

    // Parse JSON response if applicable
    var jsonResponse interface{}
    if resp.Header.Get("Content-Type") == "application/json" {
        if err := json.Unmarshal(respBody, &jsonResponse); err != nil {
            // Not valid JSON, return as string
            jsonResponse = string(respBody)
        }
    } else {
        jsonResponse = string(respBody)
    }

    // Build response object
    result := map[string]interface{}{
        "status_code": resp.StatusCode,
        "headers":     resp.Header,
        "body":        jsonResponse,
    }

    // Check for HTTP errors
    if resp.StatusCode >= 400 {
        return result, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
    }

    return result, nil
}
```

### Complete HTTPTask Implementation Structure

**http_task.go:**

```go
package tasks

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "log/slog"
    "net/http"
    "text/template"
    "time"

    "github.com/[username]/goautomation-hub/internal/engine"
)

// HTTPTask implements TaskExecutor for making HTTP requests.
type HTTPTask struct{}

// NewHTTPTask creates a new HTTP task executor.
func NewHTTPTask() *HTTPTask {
    return &HTTPTask{}
}

// Execute implements the TaskExecutor interface for HTTP requests.
func (h *HTTPTask) Execute(ctx *engine.ExecutionContext, config map[string]interface{}) engine.TaskResult {
    // Extract and validate configuration
    method, ok := config["method"].(string)
    if !ok || method == "" {
        return engine.TaskResult{
            Status: "failed",
            Error:  "missing or invalid 'method' in config",
        }
    }

    url, ok := config["url"].(string)
    if !ok || url == "" {
        return engine.TaskResult{
            Status: "failed",
            Error:  "missing or invalid 'url' in config",
        }
    }

    // Extract optional fields
    headers := make(map[string]string)
    if h, ok := config["headers"].(map[string]interface{}); ok {
        for k, v := range h {
            if strVal, ok := v.(string); ok {
                headers[k] = strVal
            }
        }
    }

    body := ""
    if b, ok := config["body"].(string); ok {
        body = b
    }

    timeout := 30 // default timeout
    if t, ok := config["timeout"].(float64); ok {
        timeout = int(t)
    }

    slog.Info("Executing HTTP request", "method", method, "url", url)

    // Interpolate body if present
    if body != "" {
        interpolated, err := h.interpolateBody(body, ctx)
        if err != nil {
            slog.Error("Body interpolation failed", "error", err)
            return engine.TaskResult{
                Status: "failed",
                Error:  fmt.Sprintf("body interpolation failed: %v", err),
            }
        }
        body = interpolated
    }

    // Interpolate headers
    for key, value := range headers {
        interpolated, err := h.interpolateString(value, ctx)
        if err != nil {
            slog.Error("Header interpolation failed", "header", key, "error", err)
            return engine.TaskResult{
                Status: "failed",
                Error:  fmt.Sprintf("header interpolation failed for '%s': %v", key, err),
            }
        }
        headers[key] = interpolated
    }

    // Execute HTTP request
    response, err := h.executeRequest(method, url, headers, body, timeout)
    if err != nil {
        slog.Error("HTTP request failed", "error", err)
        return engine.TaskResult{
            Status: "failed",
            Error:  fmt.Sprintf("HTTP request failed: %v", err),
            Output: response, // Include partial response even on error
        }
    }

    slog.Info("HTTP request successful", "status_code", response["status_code"])

    return engine.TaskResult{
        Status: "success",
        Output: response,
    }
}

// interpolateBody replaces template variables in the body string.
func (h *HTTPTask) interpolateBody(body string, ctx *engine.ExecutionContext) (string, error) {
    return h.interpolateString(body, ctx)
}

// interpolateString replaces template variables in any string.
func (h *HTTPTask) interpolateString(input string, ctx *engine.ExecutionContext) (string, error) {
    tmpl, err := template.New("interpolate").Parse(input)
    if err != nil {
        return "", fmt.Errorf("failed to parse template: %w", err)
    }

    contextData := ctx.GetAll()
    data := map[string]interface{}{
        "context": contextData,
    }

    var buf bytes.Buffer
    if err := tmpl.Execute(&buf, data); err != nil {
        return "", fmt.Errorf("failed to execute template: %w", err)
    }

    return buf.String(), nil
}

// executeRequest performs the actual HTTP request.
func (h *HTTPTask) executeRequest(method, url string, headers map[string]string, body string, timeout int) (map[string]interface{}, error) {
    // Create request body
    var reqBody io.Reader
    if body != "" {
        reqBody = bytes.NewBufferString(body)
    }

    req, err := http.NewRequest(method, url, reqBody)
    if err != nil {
        return nil, fmt.Errorf("failed to create request: %w", err)
    }

    // Set headers
    for key, value := range headers {
        req.Header.Set(key, value)
    }

    // Create HTTP client with timeout
    client := &http.Client{
        Timeout: time.Duration(timeout) * time.Second,
    }

    // Execute request
    resp, err := client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()

    // Read response body
    respBody, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("failed to read response: %w", err)
    }

    // Try to parse as JSON
    var jsonResponse interface{}
    contentType := resp.Header.Get("Content-Type")
    if contentType == "application/json" || contentType == "application/json; charset=utf-8" {
        if err := json.Unmarshal(respBody, &jsonResponse); err != nil {
            // Not valid JSON, use raw string
            jsonResponse = string(respBody)
        }
    } else {
        jsonResponse = string(respBody)
    }

    // Build response object
    result := map[string]interface{}{
        "status_code": resp.StatusCode,
        "headers":     resp.Header,
        "body":        jsonResponse,
    }

    // Return error for non-2xx status codes
    if resp.StatusCode >= 400 {
        return result, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
    }

    return result, nil
}

// RegisterHTTPTask registers the HTTP task executor with the registry.
func RegisterHTTPTask(registry *engine.Registry) {
    registry.Register("http_request", NewHTTPTask())
    slog.Info("Registered HTTP request task executor")
}
```

### File Locations and Structure

New package for task implementations:

```
internal/
├── engine/              - Core engine (Epic 1)
│   ├── context.go
│   ├── engine.go
│   ├── executor.go
│   ├── registry.go
│   └── types.go
└── tasks/               - Task implementations (Epic 2) - NEW
    ├── http_task.go     - Story 2.1
    └── http_task_test.go
```

**Package name:** `tasks`

**Import path:** `github.com/[username]/goautomation-hub/internal/tasks`

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Use `httptest` for mocking HTTP servers
- Table-driven tests for multiple scenarios
- Co-locate test files with source files

#### Testing Strategy for Story 2.1

**http_task_test.go:**

```go
package tasks

import (
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/stretchr/testify/assert"
)

func TestHTTPTask_ExecuteGET_Success(t *testing.T) {
    // Create mock HTTP server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        assert.Equal(t, "GET", r.Method)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"message": "success"})
    }))
    defer server.Close()

    // Create task and context
    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    // Configure HTTP GET request
    config := map[string]interface{}{
        "method": "GET",
        "url":    server.URL,
    }

    // Execute
    result := task.Execute(ctx, config)

    // Assertions
    assert.Equal(t, "success", result.Status)
    assert.Empty(t, result.Error)
    assert.NotNil(t, result.Output)

    output := result.Output.(map[string]interface{})
    assert.Equal(t, 200, output["status_code"])
}

func TestHTTPTask_ExecutePOST_WithBody(t *testing.T) {
    // Create mock server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        assert.Equal(t, "POST", r.Method)
        assert.Equal(t, "application/json", r.Header.Get("Content-Type"))

        // Read and verify body
        var body map[string]interface{}
        json.NewDecoder(r.Body).Decode(&body)
        assert.Equal(t, "test", body["data"])

        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(map[string]string{"id": "123"})
    }))
    defer server.Close()

    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "method": "POST",
        "url":    server.URL,
        "headers": map[string]interface{}{
            "Content-Type": "application/json",
        },
        "body": `{"data": "test"}`,
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    output := result.Output.(map[string]interface{})
    assert.Equal(t, 201, output["status_code"])
}

func TestHTTPTask_BodyInterpolation(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        var body map[string]interface{}
        json.NewDecoder(r.Body).Decode(&body)

        // Verify interpolated value
        assert.Equal(t, "interpolated_value", body["query"])

        w.WriteHeader(http.StatusOK)
        json.NewEncoder(w).Encode(map[string]string{"result": "ok"})
    }))
    defer server.Close()

    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()
    ctx.Set("search_term", "interpolated_value")

    config := map[string]interface{}{
        "method": "POST",
        "url":    server.URL,
        "headers": map[string]interface{}{
            "Content-Type": "application/json",
        },
        "body": `{"query": "{{context.search_term}}"}`,
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
}

func TestHTTPTask_HeaderInterpolation(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Verify interpolated header
        assert.Equal(t, "Bearer token123", r.Header.Get("Authorization"))

        w.WriteHeader(http.StatusOK)
    }))
    defer server.Close()

    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()
    ctx.Set("auth_token", "token123")

    config := map[string]interface{}{
        "method": "GET",
        "url":    server.URL,
        "headers": map[string]interface{}{
            "Authorization": "Bearer {{context.auth_token}}",
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
}

func TestHTTPTask_HTTPError404(t *testing.T) {
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusNotFound)
        w.Write([]byte("Not Found"))
    }))
    defer server.Close()

    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "method": "GET",
        "url":    server.URL,
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "HTTP 404")
}

func TestHTTPTask_InvalidConfig_MissingMethod(t *testing.T) {
    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "url": "http://example.com",
        // method missing
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "method")
}

func TestHTTPTask_InvalidConfig_MissingURL(t *testing.T) {
    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "method": "GET",
        // url missing
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "url")
}

func TestHTTPTask_Timeout(t *testing.T) {
    // Create slow server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(3 * time.Second)
        w.WriteHeader(http.StatusOK)
    }))
    defer server.Close()

    task := NewHTTPTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "method":  "GET",
        "url":     server.URL,
        "timeout": 1, // 1 second timeout
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "timeout")
}
```

**Coverage Target:** >80% overall, aim for 90%+ on HTTPTask.Execute()

#### Running Tests

```bash
# Run task tests
go test ./internal/tasks/... -v

# Run with coverage
go test ./internal/tasks/... -cover

# Generate coverage report
go test ./internal/tasks/... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Registration and Initialization

**Update cmd/api/main.go:**

```go
package main

import (
    "log/slog"

    "github.com/gin-gonic/gin"
    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/[username]/goautomation-hub/internal/tasks"
)

func main() {
    // Initialize task registry
    registry := engine.NewRegistry()

    // Register task executors
    tasks.RegisterHTTPTask(registry)
    // Future stories will add:
    // tasks.RegisterTransformTask(registry)
    // tasks.RegisterHTMLParserTask(registry)

    // Create engine with registry
    executionEngine := engine.NewEngine(registry)

    // Initialize Gin
    router := gin.Default()

    // Health endpoint (Story 1.1)
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "healthy"})
    })

    // TODO: Add workflow execution endpoints (Epic 3)

    slog.Info("Starting server on :8080")
    router.Run(":8080")
}
```

### Integration with Engine

The Engine (from Story 1.3) will automatically:
1. Look up "http_request" executor from registry
2. Call HTTPTask.Execute() with ExecutionContext and config
3. Store TaskResult.Output in ExecutionContext as `{task_id}_result`

**Example workflow JSON:**

```json
{
  "name": "fetch-api-data",
  "tasks": [
    {
      "id": "fetch_users",
      "type": "http_request",
      "config": {
        "method": "GET",
        "url": "https://jsonplaceholder.typicode.com/users",
        "headers": {
          "Accept": "application/json"
        }
      }
    },
    {
      "id": "fetch_specific_user",
      "type": "http_request",
      "config": {
        "method": "GET",
        "url": "https://jsonplaceholder.typicode.com/users/1"
      }
    }
  ]
}
```

After execution:
- `fetch_users_result` will be in ExecutionContext with API response
- `fetch_specific_user_result` will be in ExecutionContext
- Subsequent tasks can access these results via `{{context.fetch_users_result}}`

### Success Criteria Summary

To complete this story successfully:
1. ✅ HTTPTask struct implements TaskExecutor interface
2. ✅ Supports GET, POST, PUT, DELETE, PATCH methods
3. ✅ Supports dynamic headers from configuration
4. ✅ Implements body interpolation using text/template
5. ✅ Implements header interpolation using text/template
6. ✅ Captures HTTP response (status, headers, body) in TaskResult
7. ✅ Handles JSON responses automatically
8. ✅ Handles HTTP errors (4xx, 5xx) gracefully
9. ✅ Handles connection errors and timeouts
10. ✅ RegisterHTTPTask() function available for registry
11. ✅ Registered as "http_request" task type
12. ✅ Unit tests passing with >80% coverage
13. ✅ Integration test with Engine demonstrates end-to-end workflow

### Error Handling

**Configuration Errors:**
- Return TaskResult with status "failed" and descriptive error
- Log error using slog

**HTTP Errors:**
- Capture response even on error (include in Output)
- Return TaskResult with status "failed" and HTTP error details
- Log error with status code

**Template Errors:**
- Return TaskResult with status "failed" and template error
- Log interpolation failures

**Network Errors:**
- Return TaskResult with status "failed" and network error details
- Log connection failures

### Performance Considerations
[Source: prd/requirements.md - NFR4]

- HTTP requests are I/O bound, not computation bound
- Use default timeout (30s) but allow configuration
- Don't buffer large responses in memory unnecessarily
- Engine overhead should be <50ms (HTTP request time is separate)

### Future Enhancements (Not in this story)

- Retry logic (will be added per FR8 in future stories)
- Request/response logging to database (Epic 3)
- Authentication helpers (OAuth, API keys)
- Request body from file
- Response streaming for large payloads

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by the QA Agent after story completion*
