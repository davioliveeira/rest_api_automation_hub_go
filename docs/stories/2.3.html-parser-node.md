# Story 2.3: HTML Parser Node (Goquery)

## Status
Ready for Review

## Story
**As a** Workflow Designer,
**I want** an HTML parser task node that uses CSS selectors to extract structured data from HTML content,
**so that** workflows can scrape web pages and extract specific elements for processing by subsequent tasks.

## Acceptance Criteria
1. **AC1:** Extração via seletores CSS devolvendo `[]map[string]any`.

## Tasks / Subtasks

- [x] Task 1: Create HTML Parser task structure (AC: 1)
  - [x] Create `internal/tasks/html_parser_task.go` file
  - [x] Define `HTMLParserTask` struct implementing `TaskExecutor` interface
  - [x] Add Goquery package dependency to go.mod
  - [x] Add package documentation for HTML parsing functionality

- [x] Task 2: Implement HTML parser configuration (AC: 1)
  - [x] Define configuration structure for HTML parsing
  - [x] Support `html_source` field (context key containing HTML string)
  - [x] Support `selectors` field (array of selector definitions)
  - [x] Each selector has: `name` (output field name), `selector` (CSS selector), `attribute` (optional), `multiple` (optional boolean)

- [x] Task 3: Implement CSS selector extraction (AC: 1)
  - [x] Load HTML from ExecutionContext based on html_source
  - [x] Parse HTML using Goquery
  - [x] For each selector configuration:
    - [x] Apply CSS selector to find element(s)
    - [x] Extract text content or attribute value
    - [x] Handle single vs multiple matches
  - [x] Build result as `[]map[string]any` per AC1

- [x] Task 4: Implement Execute method (AC: 1)
  - [x] Validate configuration (required: html_source, selectors)
  - [x] Load HTML content from ExecutionContext
  - [x] Parse HTML document with Goquery
  - [x] Execute all selectors and collect results
  - [x] Return TaskResult with extracted data array

- [x] Task 5: Support multiple extraction patterns (AC: 1)
  - [x] Single element extraction (first match)
  - [x] Multiple element extraction (all matches)
  - [x] Attribute extraction (href, src, class, etc.)
  - [x] Text content extraction (default)

- [x] Task 6: Implement error handling (AC: 1)
  - [x] Handle missing HTML source in context
  - [x] Handle invalid HTML parsing errors
  - [x] Handle invalid CSS selectors
  - [x] Handle empty selector results (warn but don't fail)
  - [x] Return descriptive error messages in TaskResult.Error
  - [x] Log errors using `slog`

- [x] Task 7: Store extracted data in ExecutionContext (AC: 1)
  - [x] Return extracted data array in TaskResult.Output
  - [x] Format as `[]map[string]any` per AC1
  - [x] Engine will store TaskResult.Output in context
  - [x] Data available for Transform or other tasks

- [x] Task 8: Register HTML Parser task with Registry
  - [x] Create initialization function `RegisterHTMLParserTask(registry *engine.Registry)`
  - [x] Register with task type name "html_parser"
  - [x] Update main.go initialization to call registration
  - [x] Document registration in code comments

- [x] Task 9: Write comprehensive unit tests (Testing requirement)
  - [x] Create `internal/tasks/html_parser_task_test.go`
  - [x] Test single element extraction
  - [x] Test multiple element extraction
  - [x] Test attribute extraction (href, src)
  - [x] Test nested selectors
  - [x] Test empty results handling
  - [x] Test invalid HTML handling
  - [x] Test missing HTML source
  - [x] Ensure >80% test coverage

- [x] Task 10: Integration test with HTTP and Transform tasks
  - [x] Create workflow: HTTP fetch HTML -> Parse -> Transform -> verify
  - [x] Test extracting data from real HTML structure
  - [x] Verify parsed data available for transformation
  - [x] Test end-to-end scraping workflow

## Dev Notes

### Epic Foundation Context

**Epic 1 Foundation (Stories 1.1-1.3):**
- Standard Go Project Layout with `/internal/tasks/` package
- ExecutionContext with Get/Set/GetAll for data sharing
- Engine with TaskExecutor interface and Registry system
- TaskResult with Status, Output, Error fields

**Epic 2 Task Nodes (Stories 2.1-2.2):**

**Story 2.1 (HTTP Request Node):**
- Fetches HTML content from URLs
- HTTP response stored in context includes HTML body
- **Integration Point:** Story 2.3 parses HTML from HTTP responses

**Story 2.2 (Transform Node):**
- Transforms structured data using Go templates
- **Integration Point:** Story 2.3 outputs structured data for transformation

**Story 2.3 Completes the Data Pipeline:**
```
HTTP Task → HTML Parser → Transform Task
(fetch)     (extract)     (reshape)
```

### TaskExecutor Interface Contract
[Source: Story 1.3 - internal/engine/executor.go]

```go
type TaskExecutor interface {
    Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult
}
```

Must implement Execute method accepting ExecutionContext and config, returning TaskResult.

### Functional Requirement FR5
[Source: prd/requirements.md - FR5]

**FR5:** "Implementar nó `html_parser` usando seletores CSS (via Goquery) para extrair dados estruturados."

**Requirements:**
- Use Goquery library for CSS selector support
- Extract structured data (not just raw HTML)
- Return as `[]map[string]any` per AC1

### HTML Parser Purpose

**What is HTML Parsing/Scraping?**
Taking HTML content and:
- Selecting specific elements using CSS selectors
- Extracting text content or attributes
- Building structured data for processing
- Enabling data-driven workflows from web content

**Example Use Case (Airbnb Scraping - Epic 4):**
```
HTTP Task fetches: <HTML with property listings>

HTML Parser extracts:
[
  {"title": "Beach House", "price": "$150/night", "rating": "4.8"},
  {"title": "Mountain Cabin", "price": "$200/night", "rating": "4.9"},
  ...
]

Transform Task can then reshape/filter data
```

### Configuration Structure

The workflow JSON will provide configuration like this:

```json
{
  "id": "parse_listings",
  "type": "html_parser",
  "config": {
    "html_source": "fetch_page_result",
    "selectors": [
      {
        "name": "title",
        "selector": ".listing-title",
        "multiple": false
      },
      {
        "name": "price",
        "selector": ".listing-price",
        "multiple": false
      },
      {
        "name": "links",
        "selector": ".listing-link",
        "attribute": "href",
        "multiple": true
      }
    ]
  }
}
```

**Configuration Fields:**
- `html_source` (string, required): ExecutionContext key containing HTML string
- `selectors` (array, required): Array of selector definitions

**Selector Definition:**
- `name` (string, required): Field name in output map
- `selector` (string, required): CSS selector
- `attribute` (string, optional): Extract attribute instead of text (e.g., "href", "src")
- `multiple` (boolean, optional): Extract all matches (true) or first match (false, default)

### Goquery Primer

**Goquery** is a jQuery-like library for Go that implements CSS selectors.

**Installation:**
```bash
go get github.com/PuerkitoBio/goquery
```

**Basic Usage:**
```go
import "github.com/PuerkitoBio/goquery"

// Parse HTML
doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))

// Select single element
title := doc.Find(".title").First().Text()

// Select multiple elements
doc.Find(".item").Each(func(i int, s *goquery.Selection) {
    text := s.Text()
    // Process each item
})

// Get attribute
link, exists := doc.Find("a").Attr("href")
```

**CSS Selector Examples:**
- `.class-name` - Element with class
- `#id-name` - Element with ID
- `div.class` - Div with class
- `div > p` - Direct child
- `div p` - Descendant
- `a[href]` - Element with attribute
- `.parent .child` - Nested elements

### Complete HTMLParserTask Implementation

**html_parser_task.go:**

```go
package tasks

import (
    "fmt"
    "log/slog"
    "strings"

    "github.com/PuerkitoBio/goquery"
    "github.com/[username]/goautomation-hub/internal/engine"
)

// HTMLParserTask implements TaskExecutor for HTML parsing with CSS selectors.
type HTMLParserTask struct{}

// NewHTMLParserTask creates a new HTML parser task executor.
func NewHTMLParserTask() *HTMLParserTask {
    return &HTMLParserTask{}
}

// SelectorConfig defines a CSS selector extraction rule.
type SelectorConfig struct {
    Name      string
    Selector  string
    Attribute string // Optional: extract attribute instead of text
    Multiple  bool   // Extract all matches or just first
}

// Execute implements the TaskExecutor interface for HTML parsing.
func (h *HTMLParserTask) Execute(ctx *engine.ExecutionContext, config map[string]interface{}) engine.TaskResult {
    // Extract and validate configuration
    htmlSource, ok := config["html_source"].(string)
    if !ok || htmlSource == "" {
        return engine.TaskResult{
            Status: "failed",
            Error:  "missing or invalid 'html_source' in config",
        }
    }

    selectorsConfig, ok := config["selectors"].([]interface{})
    if !ok || len(selectorsConfig) == 0 {
        return engine.TaskResult{
            Status: "failed",
            Error:  "missing or invalid 'selectors' in config",
        }
    }

    // Load HTML from context
    htmlData, exists := ctx.Get(htmlSource)
    if !exists {
        return engine.TaskResult{
            Status: "failed",
            Error:  fmt.Sprintf("HTML source '%s' not found in context", htmlSource),
        }
    }

    // Extract HTML string from response
    htmlString := h.extractHTMLString(htmlData)
    if htmlString == "" {
        return engine.TaskResult{
            Status: "failed",
            Error:  "HTML content is empty or invalid",
        }
    }

    slog.Info("Parsing HTML", "source", htmlSource, "html_length", len(htmlString), "selector_count", len(selectorsConfig))

    // Parse HTML with Goquery
    doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlString))
    if err != nil {
        slog.Error("HTML parsing failed", "error", err)
        return engine.TaskResult{
            Status: "failed",
            Error:  fmt.Sprintf("failed to parse HTML: %v", err),
        }
    }

    // Parse selector configurations
    selectors := h.parseSelectors(selectorsConfig)
    if len(selectors) == 0 {
        return engine.TaskResult{
            Status: "failed",
            Error:  "no valid selectors provided",
        }
    }

    // Execute selectors and extract data
    results := h.extractData(doc, selectors)

    slog.Info("HTML parsing successful", "results_count", len(results))

    return engine.TaskResult{
        Status: "success",
        Output: results,
    }
}

// extractHTMLString extracts HTML string from various data formats.
func (h *HTMLParserTask) extractHTMLString(data interface{}) string {
    switch v := data.(type) {
    case string:
        return v
    case map[string]interface{}:
        // Likely HTTP response - try to get body
        if body, ok := v["body"]; ok {
            if bodyStr, ok := body.(string); ok {
                return bodyStr
            }
        }
        return ""
    default:
        return ""
    }
}

// parseSelectors converts config to SelectorConfig structs.
func (h *HTMLParserTask) parseSelectors(selectorsConfig []interface{}) []SelectorConfig {
    selectors := make([]SelectorConfig, 0, len(selectorsConfig))

    for _, sc := range selectorsConfig {
        selectorMap, ok := sc.(map[string]interface{})
        if !ok {
            continue
        }

        name, _ := selectorMap["name"].(string)
        selector, _ := selectorMap["selector"].(string)

        if name == "" || selector == "" {
            slog.Warn("Skipping invalid selector", "config", selectorMap)
            continue
        }

        config := SelectorConfig{
            Name:     name,
            Selector: selector,
        }

        if attr, ok := selectorMap["attribute"].(string); ok {
            config.Attribute = attr
        }

        if multiple, ok := selectorMap["multiple"].(bool); ok {
            config.Multiple = multiple
        }

        selectors = append(selectors, config)
    }

    return selectors
}

// extractData applies selectors and builds result array.
func (h *HTMLParserTask) extractData(doc *goquery.Document, selectors []SelectorConfig) []map[string]interface{} {
    // Determine if we need to extract multiple records or single record
    hasMultipleExtractor := false
    for _, s := range selectors {
        if s.Multiple {
            hasMultipleExtractor = true
            break
        }
    }

    if hasMultipleExtractor {
        return h.extractMultipleRecords(doc, selectors)
    }

    return h.extractSingleRecord(doc, selectors)
}

// extractSingleRecord extracts one record with all selector results.
func (h *HTMLParserTask) extractSingleRecord(doc *goquery.Document, selectors []SelectorConfig) []map[string]interface{} {
    record := make(map[string]interface{})

    for _, sc := range selectors {
        selection := doc.Find(sc.Selector)

        if sc.Multiple {
            // Extract all matches
            values := make([]string, 0)
            selection.Each(func(i int, s *goquery.Selection) {
                value := h.extractValue(s, sc.Attribute)
                if value != "" {
                    values = append(values, value)
                }
            })
            record[sc.Name] = values
        } else {
            // Extract first match
            if selection.Length() > 0 {
                value := h.extractValue(selection.First(), sc.Attribute)
                record[sc.Name] = value
            } else {
                slog.Warn("Selector found no matches", "selector", sc.Selector, "name", sc.Name)
                record[sc.Name] = ""
            }
        }
    }

    return []map[string]interface{}{record}
}

// extractMultipleRecords extracts multiple records based on a parent selector.
// Note: This is a simplified implementation. For more complex scenarios,
// one selector should define the "container" and others extract from within.
func (h *HTMLParserTask) extractMultipleRecords(doc *goquery.Document, selectors []SelectorConfig) []map[string]interface{} {
    // For simplicity, if multiple=true on any selector, extract arrays in single record
    return h.extractSingleRecord(doc, selectors)
}

// extractValue gets text or attribute from a selection.
func (h *HTMLParserTask) extractValue(s *goquery.Selection, attribute string) string {
    if attribute != "" {
        // Extract attribute
        value, exists := s.Attr(attribute)
        if exists {
            return strings.TrimSpace(value)
        }
        return ""
    }

    // Extract text content
    return strings.TrimSpace(s.Text())
}

// RegisterHTMLParserTask registers the HTML parser task executor with the registry.
func RegisterHTMLParserTask(registry *engine.Registry) {
    registry.Register("html_parser", NewHTMLParserTask())
    slog.Info("Registered HTML Parser task executor")
}
```

### Tech Stack - Goquery
[Source: architecture/4-tech-stack.md]

- **HTML Parser:** Goquery v1.8+
- **Purpose:** "Scraping baseado em CSS Selectors"
- jQuery-like API for Go
- Full CSS selector support
- Lightweight and fast

### External APIs - Airbnb Scraping Context
[Source: architecture/7-external-apis.md]

- **Airbnb:** "Alvo de scraping para validação do motor"
- HTML Parser is critical for Epic 4 (MVP Validation - Scraper Airbnb)
- Will extract property listings, prices, ratings from Airbnb pages

### CSS Selector Examples for Common Patterns

**1. Extract Text from Single Element:**
```json
{
  "name": "page_title",
  "selector": "h1.title",
  "multiple": false
}
```

**2. Extract All Links:**
```json
{
  "name": "navigation_links",
  "selector": "nav a",
  "attribute": "href",
  "multiple": true
}
```

**3. Extract List Items:**
```json
{
  "name": "product_names",
  "selector": ".product .name",
  "multiple": true
}
```

**4. Extract Image Sources:**
```json
{
  "name": "images",
  "selector": "img.gallery",
  "attribute": "src",
  "multiple": true
}
```

**5. Nested Selectors:**
```json
{
  "name": "article_title",
  "selector": "article .header .title",
  "multiple": false
}
```

### Real-World Scraping Examples

**Example 1: Extract Product Listings**

HTML Input:
```html
<div class="products">
  <div class="product">
    <h3 class="title">Product 1</h3>
    <span class="price">$10.99</span>
  </div>
  <div class="product">
    <h3 class="title">Product 2</h3>
    <span class="price">$15.99</span>
  </div>
</div>
```

Configuration:
```json
{
  "html_source": "page_html_result",
  "selectors": [
    {
      "name": "titles",
      "selector": ".product .title",
      "multiple": true
    },
    {
      "name": "prices",
      "selector": ".product .price",
      "multiple": true
    }
  ]
}
```

Output:
```json
[
  {
    "titles": ["Product 1", "Product 2"],
    "prices": ["$10.99", "$15.99"]
  }
]
```

**Example 2: Extract Navigation Links**

HTML Input:
```html
<nav>
  <a href="/home">Home</a>
  <a href="/about">About</a>
  <a href="/contact">Contact</a>
</nav>
```

Configuration:
```json
{
  "html_source": "page_html_result",
  "selectors": [
    {
      "name": "nav_links",
      "selector": "nav a",
      "attribute": "href",
      "multiple": true
    },
    {
      "name": "nav_labels",
      "selector": "nav a",
      "multiple": true
    }
  ]
}
```

Output:
```json
[
  {
    "nav_links": ["/home", "/about", "/contact"],
    "nav_labels": ["Home", "About", "Contact"]
  }
]
```

**Example 3: Extract Single Page Metadata**

HTML Input:
```html
<html>
  <head>
    <title>My Page</title>
    <meta name="description" content="Page description">
  </head>
  <body>
    <h1>Welcome</h1>
  </body>
</html>
```

Configuration:
```json
{
  "html_source": "page_html_result",
  "selectors": [
    {
      "name": "title",
      "selector": "title",
      "multiple": false
    },
    {
      "name": "heading",
      "selector": "h1",
      "multiple": false
    },
    {
      "name": "description",
      "selector": "meta[name='description']",
      "attribute": "content",
      "multiple": false
    }
  ]
}
```

Output:
```json
[
  {
    "title": "My Page",
    "heading": "Welcome",
    "description": "Page description"
  }
]
```

### File Locations and Structure

Completing `/internal/tasks/` package for Epic 2:

```
internal/tasks/
├── http_task.go              - Story 2.1
├── http_task_test.go         - Story 2.1
├── transform_task.go         - Story 2.2
├── transform_task_test.go    - Story 2.2
├── html_parser_task.go       - Story 2.3 (NEW)
└── html_parser_task_test.go  - Story 2.3 (NEW)
```

**Package name:** `tasks`

**Import path:** `github.com/[username]/goautomation-hub/internal/tasks`

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Use real HTML strings for testing (no external dependencies)
- Table-driven tests for multiple selector scenarios
- Co-locate test files with source files

#### Testing Strategy for Story 2.3

**html_parser_task_test.go:**

```go
package tasks

import (
    "testing"

    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/stretchr/testify/assert"
)

func TestHTMLParserTask_SingleElementExtraction(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `
        <html>
            <body>
                <h1 class="title">Test Title</h1>
                <p class="description">Test Description</p>
            </body>
        </html>
    `

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "title",
                "selector": ".title",
            },
            map[string]interface{}{
                "name":     "description",
                "selector": ".description",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.NotNil(t, result.Output)

    outputArray := result.Output.([]map[string]interface{})
    assert.Len(t, outputArray, 1)

    record := outputArray[0]
    assert.Equal(t, "Test Title", record["title"])
    assert.Equal(t, "Test Description", record["description"])
}

func TestHTMLParserTask_MultipleElementExtraction(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `
        <ul>
            <li class="item">Item 1</li>
            <li class="item">Item 2</li>
            <li class="item">Item 3</li>
        </ul>
    `

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "items",
                "selector": ".item",
                "multiple": true,
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    assert.Len(t, outputArray, 1)

    items := outputArray[0]["items"].([]string)
    assert.Len(t, items, 3)
    assert.Equal(t, "Item 1", items[0])
    assert.Equal(t, "Item 2", items[1])
    assert.Equal(t, "Item 3", items[2])
}

func TestHTMLParserTask_AttributeExtraction(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `
        <nav>
            <a href="/home">Home</a>
            <a href="/about">About</a>
            <a href="/contact">Contact</a>
        </nav>
    `

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":      "links",
                "selector":  "nav a",
                "attribute": "href",
                "multiple":  true,
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    links := outputArray[0]["links"].([]string)
    assert.Len(t, links, 3)
    assert.Equal(t, "/home", links[0])
    assert.Equal(t, "/about", links[1])
    assert.Equal(t, "/contact", links[2])
}

func TestHTMLParserTask_NestedSelectors(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `
        <div class="container">
            <div class="header">
                <h1 class="title">Nested Title</h1>
            </div>
        </div>
    `

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "title",
                "selector": ".container .header .title",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    assert.Equal(t, "Nested Title", outputArray[0]["title"])
}

func TestHTMLParserTask_EmptyResults(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `<html><body><p>Content</p></body></html>`

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "nonexistent",
                "selector": ".does-not-exist",
            },
        },
    }

    result := task.Execute(ctx, config)

    // Should succeed but with empty value
    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    assert.Equal(t, "", outputArray[0]["nonexistent"])
}

func TestHTMLParserTask_MissingHTMLSource(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    // Don't set "page_html" in context

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "title",
                "selector": ".title",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "not found in context")
}

func TestHTMLParserTask_InvalidHTML(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    // Goquery is pretty forgiving, so most "invalid" HTML will still parse
    // Test with completely empty content
    ctx.Set("page_html", "")

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "title",
                "selector": ".title",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "empty")
}

func TestHTMLParserTask_MissingConfig(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        // Missing html_source
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "title",
                "selector": ".title",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "html_source")
}

func TestHTMLParserTask_HTTPResponseBody(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    // Simulate HTTP response from Story 2.1
    httpResponse := map[string]interface{}{
        "status_code": 200,
        "body":        `<html><body><h1>From HTTP</h1></body></html>`,
    }

    ctx.Set("http_result", httpResponse)

    config := map[string]interface{}{
        "html_source": "http_result",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "heading",
                "selector": "h1",
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    assert.Equal(t, "From HTTP", outputArray[0]["heading"])
}

func TestHTMLParserTask_ComplexExtraction(t *testing.T) {
    task := NewHTMLParserTask()
    ctx := engine.NewExecutionContext()

    htmlContent := `
        <div class="products">
            <div class="product">
                <h3 class="name">Product A</h3>
                <span class="price">$10</span>
                <a href="/product-a" class="link">View</a>
            </div>
            <div class="product">
                <h3 class="name">Product B</h3>
                <span class="price">$20</span>
                <a href="/product-b" class="link">View</a>
            </div>
        </div>
    `

    ctx.Set("page_html", htmlContent)

    config := map[string]interface{}{
        "html_source": "page_html",
        "selectors": []interface{}{
            map[string]interface{}{
                "name":     "product_names",
                "selector": ".product .name",
                "multiple": true,
            },
            map[string]interface{}{
                "name":     "product_prices",
                "selector": ".product .price",
                "multiple": true,
            },
            map[string]interface{}{
                "name":      "product_links",
                "selector":  ".product .link",
                "attribute": "href",
                "multiple":  true,
            },
        },
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    outputArray := result.Output.([]map[string]interface{})
    record := outputArray[0]

    names := record["product_names"].([]string)
    assert.Len(t, names, 2)
    assert.Equal(t, "Product A", names[0])

    prices := record["product_prices"].([]string)
    assert.Len(t, prices, 2)
    assert.Equal(t, "$10", prices[0])

    links := record["product_links"].([]string)
    assert.Len(t, links, 2)
    assert.Equal(t, "/product-a", links[0])
}
```

**Coverage Target:** >80% overall, aim for 90%+ on HTMLParserTask.Execute()

#### Running Tests

```bash
# Run HTML parser tests
go test ./internal/tasks/html_parser_task_test.go -v

# Run all task tests
go test ./internal/tasks/... -v

# Run with coverage
go test ./internal/tasks/... -cover

# Generate coverage report
go test ./internal/tasks/... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Registration and Initialization

**Update cmd/api/main.go:**

```go
package main

import (
    "log/slog"

    "github.com/gin-gonic/gin"
    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/[username]/goautomation-hub/internal/tasks"
)

func main() {
    // Initialize task registry
    registry := engine.NewRegistry()

    // Register task executors (Epic 2 complete!)
    tasks.RegisterHTTPTask(registry)        // Story 2.1
    tasks.RegisterTransformTask(registry)   // Story 2.2
    tasks.RegisterHTMLParserTask(registry)  // Story 2.3

    // Create engine with registry
    executionEngine := engine.NewEngine(registry)

    // Initialize Gin
    router := gin.Default()

    // Health endpoint
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "healthy"})
    })

    // TODO: Add workflow execution endpoints (Epic 3)

    slog.Info("Starting server on :8080")
    router.Run(":8080")
}
```

### Integration: Complete Data Pipeline

**Example Workflow: HTTP → Parse → Transform**

```json
{
  "name": "scrape-and-process",
  "tasks": [
    {
      "id": "fetch_page",
      "type": "http_request",
      "config": {
        "method": "GET",
        "url": "https://example.com/products"
      }
    },
    {
      "id": "parse_products",
      "type": "html_parser",
      "config": {
        "html_source": "fetch_page_result",
        "selectors": [
          {
            "name": "product_names",
            "selector": ".product .name",
            "multiple": true
          },
          {
            "name": "product_prices",
            "selector": ".product .price",
            "multiple": true
          }
        ]
      }
    },
    {
      "id": "format_output",
      "type": "transform",
      "config": {
        "template": "Found {{len .product_names}} products",
        "data_source": "parse_products_result",
        "output_format": "string"
      }
    }
  ]
}
```

**Execution Flow:**
1. `fetch_page` (Story 2.1): Fetches HTML from URL
2. HTTP response stored in context as `fetch_page_result`
3. `parse_products` (Story 2.3): Parses HTML, extracts product data
4. Parsed data stored as `parse_products_result`
5. `format_output` (Story 2.2): Transforms parsed data
6. Final result stored as `format_output_result`

### Success Criteria Summary

To complete this story successfully:
1. ✅ HTMLParserTask struct implements TaskExecutor interface
2. ✅ Uses Goquery for CSS selector support
3. ✅ Supports `html_source` configuration (context key)
4. ✅ Supports `selectors` array configuration
5. ✅ Each selector supports: name, selector, attribute (optional), multiple (optional)
6. ✅ Extracts text content (default) or attribute values
7. ✅ Handles single element extraction (first match)
8. ✅ Handles multiple element extraction (all matches)
9. ✅ Returns `[]map[string]any` format per AC1
10. ✅ Handles missing HTML source gracefully
11. ✅ Handles empty selector results gracefully (warning, not failure)
12. ✅ Works with HTTP task response format (extracts body from map)
13. ✅ RegisterHTMLParserTask() function available for registry
14. ✅ Registered as "html_parser" task type
15. ✅ Unit tests passing with >80% coverage
16. ✅ Integration test with HTTP and Transform tasks demonstrates pipeline

### Error Handling

**Configuration Errors:**
- Return TaskResult with status "failed" for missing html_source
- Return TaskResult with status "failed" for missing/invalid selectors
- Log errors using slog

**HTML Parsing Errors:**
- Return TaskResult with status "failed" for invalid HTML
- Log parsing failures

**Missing Data:**
- Return TaskResult with status "failed" if HTML source not in context
- Return TaskResult with status "failed" if HTML content is empty

**Empty Selector Results:**
- Log warning but continue (return empty string for that field)
- Don't fail the entire task if one selector finds nothing

### Performance Considerations
[Source: prd/requirements.md - NFR4]

- Goquery is efficient for HTML parsing
- CSS selector matching is fast
- Engine overhead should be <50ms (HTML parsing time is separate)
- For large HTML documents, selector performance may vary

### Comparison with Stories 2.1 and 2.2

**Story 2.1 (HTTP Task):**
- **Purpose:** Fetch HTML/JSON from URLs
- **Output:** Raw HTTP response (status, headers, body)
- **Data Flow:** External API → Context

**Story 2.2 (Transform Task):**
- **Purpose:** Transform structured data
- **Input:** Structured data (maps, arrays)
- **Output:** Reshaped structured data
- **Data Flow:** Context → Transform → Context

**Story 2.3 (HTML Parser Task):**
- **Purpose:** Extract structured data from HTML
- **Input:** HTML string (often from HTTP task)
- **Output:** Structured data (arrays of maps)
- **Data Flow:** Context HTML → Parse → Structured Context

**Complete Pipeline:**
```
HTTP (2.1) → HTML Parser (2.3) → Transform (2.2)
Fetch HTML    Extract Data         Reshape Data
```

### Future Enhancements (Not in this story)

- Per-container parsing (extract multiple complete records with nested selectors)
- XPath selector support (in addition to CSS)
- JavaScript execution for dynamic content (requires headless browser)
- HTML cleaning/sanitization options
- Pagination support

### Epic 4 Preparation

**Airbnb Scraping (Epic 4 - MVP Validation):**

This HTML Parser will be essential for Epic 4's Airbnb scraper workflow:
- HTTP Task fetches Airbnb listing pages
- HTML Parser extracts: property names, prices, ratings, images
- Transform Task formats data for notifications
- Database Task stores listings (Epic 3)

Story 2.3 completes the scraping foundation!

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |
| 2026-01-17 | 1.1 | Implementation completed - HTMLParserTask with Goquery, CSS selectors, 18 unit tests + 4 integration tests (91.9% coverage) | James (Dev) |

## Dev Agent Record

*This section was populated by the development agent during implementation*

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - Implementation completed without issues requiring debug logging

### Completion Notes List
- **HTMLParserTask Implementation**: Full HTML parser using Goquery library for CSS selector-based extraction of structured data
- **New Dependency Added**: github.com/PuerkitoBio/goquery v1.11.0 for HTML parsing with CSS selectors
- **Configuration Support**: html_source (required - context key), selectors array (required - each with name, selector, attribute (optional), multiple (optional))
- **CSS Selector Extraction**: Single element (first match) and multiple element (all matches) support, text content and attribute extraction
- **Data Format**: Returns []map[string]any per AC1 requirement for structured output
- **HTML Source Handling**: Supports direct HTML strings and nested structures (e.g., HTTP response body extraction)
- **Error Handling**: Comprehensive error handling for missing HTML source, invalid selectors, parsing errors, empty results (warn but continue)
- **Test Coverage**: 91.9% coverage on tasks package with 18 unit tests + 4 integration tests
- **Integration Tests**: HTTP → HTML Parser, HTTP → HTML Parser → Transform complete pipeline, real-world Airbnb scraping simulation
- **Registry Integration**: Successfully registered as "html_parser" task type with RegisterHTMLParserTask function
- **Main.go Updated**: Added HTML Parser task registration alongside HTTP and Transform tasks
- **No Regressions**: All existing tests continue to pass (engine: 100%, cmd/api: 40.9%, tasks: 91.9%)

### File List
**Created Files:**
- `internal/tasks/html_parser_task.go` (234 lines) - HTMLParserTask struct implementing TaskExecutor interface, SelectorConfig struct, parseSelectors, extractData, extractValue helper methods, and RegisterHTMLParserTask function
- `internal/tasks/html_parser_task_test.go` (616 lines) - 18 unit tests covering single/multiple element extraction, attribute extraction (href, src), nested selectors, empty results, error handling, HTTP response structure compatibility, complex HTML structures

**Modified Files:**
- `internal/tasks/integration_test.go` (added 4 integration tests: 468 lines added) - Integration tests for HTML Parser with Engine, HTTP+HTML Parser workflow, complete HTTP→HTMLParser→Transform pipeline, real-world Airbnb scraping simulation
- `go.mod` - Added github.com/PuerkitoBio/goquery v1.11.0 and github.com/andybalholm/cascadia v1.3.3 dependencies
- `go.sum` - Dependency checksums for Goquery and Cascadia
- `cmd/api/main.go` - Added HTML Parser task registration in main function initialization
- `docs/stories/2.3.html-parser-node.md` - Updated task checkboxes and Dev Agent Record section

## QA Results

*This section will be populated by the QA Agent after story completion*
