# Story 2.2: Transform Node (Go Templates)

## Status
Draft

## Story
**As a** Workflow Designer,
**I want** a data transformation task node that uses Go templates to reshape and extract data from the execution context,
**so that** workflows can manipulate data structures, extract specific fields, and prepare data for subsequent tasks.

## Acceptance Criteria
1. **AC1:** Interpolação de dados usando `text/template` nativo do Go.

## Tasks / Subtasks

- [ ] Task 1: Create Transform task structure (AC: 1)
  - [ ] Create `internal/tasks/transform_task.go` file
  - [ ] Define `TransformTask` struct implementing `TaskExecutor` interface
  - [ ] Add package documentation for transform functionality

- [ ] Task 2: Implement transform configuration (AC: 1)
  - [ ] Define configuration structure for transforms
  - [ ] Support `template` field (Go template string)
  - [ ] Support `data_source` field (optional: specific context key, default: all context)
  - [ ] Support `output_format` field (optional: "json", "string", default: "json")

- [ ] Task 3: Implement template execution (AC: 1)
  - [ ] Parse Go template from configuration
  - [ ] Load data from ExecutionContext (specific key or all context)
  - [ ] Execute template with loaded data
  - [ ] Handle template execution errors gracefully

- [ ] Task 4: Implement Execute method (AC: 1)
  - [ ] Validate configuration (required field: template)
  - [ ] Load data from ExecutionContext based on data_source
  - [ ] Parse and execute Go template
  - [ ] Format output based on output_format
  - [ ] Return TaskResult with transformed data

- [ ] Task 5: Support advanced template functions (AC: 1)
  - [ ] Add custom template functions (e.g., toUpper, toLower, join)
  - [ ] Support JSON manipulation functions
  - [ ] Support array/slice operations
  - [ ] Document available template functions

- [ ] Task 6: Implement error handling (AC: 1)
  - [ ] Handle template parsing errors
  - [ ] Handle template execution errors
  - [ ] Handle invalid data source references
  - [ ] Return descriptive error messages in TaskResult.Error
  - [ ] Log errors using `slog`

- [ ] Task 7: Store transformed data in ExecutionContext (AC: 1)
  - [ ] Return transformed data in TaskResult.Output
  - [ ] Engine will store TaskResult.Output in context
  - [ ] Transformed data available for subsequent tasks

- [ ] Task 8: Register Transform task with Registry
  - [ ] Create initialization function `RegisterTransformTask(registry *engine.Registry)`
  - [ ] Register with task type name "transform"
  - [ ] Update main.go initialization to call registration
  - [ ] Document registration in code comments

- [ ] Task 9: Write comprehensive unit tests (Testing requirement)
  - [ ] Create `internal/tasks/transform_task_test.go`
  - [ ] Test simple field extraction
  - [ ] Test data reshaping/restructuring
  - [ ] Test template with custom functions
  - [ ] Test combining data from multiple context keys
  - [ ] Test error handling (invalid template, missing data)
  - [ ] Test JSON output formatting
  - [ ] Ensure >80% test coverage

- [ ] Task 10: Integration test with Engine and HTTP task
  - [ ] Create workflow: HTTP fetch -> Transform -> verify
  - [ ] Test transforming HTTP response data
  - [ ] Verify transformed data available in context
  - [ ] Test end-to-end workflow execution

## Dev Notes

### Epic Foundation Context

**Epic 1 Foundation (Stories 1.1-1.3):**
- Standard Go Project Layout with `/internal/tasks/` for task implementations
- ExecutionContext with Get/Set/GetAll methods for data sharing
- Engine with sequential task execution loop
- TaskExecutor interface: `Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult`
- Registry system for dynamic task registration
- TaskResult with Status, Output, Error fields

**Story 2.1 (HTTP Request Node) - Pattern Established:**
- Created `/internal/tasks/` package structure
- Implemented first TaskExecutor with full error handling
- Used `text/template` for **string interpolation** (headers, body)
- Registration pattern: `RegisterHTTPTask(registry)`
- Comprehensive test coverage with httptest
- Integration with main.go initialization

**Story 2.2 Builds On Story 2.1:**
Story 2.1 used `text/template` for **string interpolation** (replacing `{{context.key}}` in strings).
Story 2.2 uses `text/template` for **data transformation** (reshaping structured data).

### TaskExecutor Interface Contract
[Source: Story 1.3 - internal/engine/executor.go]

```go
type TaskExecutor interface {
    Execute(ctx *ExecutionContext, config map[string]interface{}) TaskResult
}
```

Must implement Execute method accepting ExecutionContext and config, returning TaskResult.

### Functional Requirement FR7
[Source: prd/requirements.md - FR7]

**FR7:** "Implementar nó `transform` usando a biblioteca nativa `text/template` para mapeamento de dados."

**Requirements:**
- Use Go's native `text/template` package
- Support data mapping/transformation
- Transform data between tasks in workflow

### Transform Node Purpose

**What is Data Transformation?**
Taking structured data (e.g., JSON from HTTP response) and:
- Extracting specific fields
- Reshaping data structures
- Combining data from multiple sources
- Formatting for specific requirements

**Example Use Case:**
```
HTTP Task fetches: {"users": [{"id": 1, "name": "Alice", "email": "alice@example.com"}, ...]}

Transform Task extracts: ["Alice", "Bob", "Charlie"]  (just names)

Next Task can use: Clean list of names
```

### Configuration Structure

The workflow JSON will provide configuration like this:

```json
{
  "id": "extract_names",
  "type": "transform",
  "config": {
    "template": "{{range .users}}{{.name}}\n{{end}}",
    "data_source": "fetch_users_result",
    "output_format": "string"
  }
}
```

**Configuration Fields:**
- `template` (string, required): Go template string defining transformation
- `data_source` (string, optional): Specific ExecutionContext key to use as input. If omitted, entire context available.
- `output_format` (string, optional): "json" or "string" (default: "json")

### Go Template Primer

**Basic Syntax:**
```
{{.fieldName}}           - Access field
{{range .array}}...{{end}} - Loop over array
{{if .condition}}...{{end}} - Conditional
{{.field | function}}    - Pipe to function
```

**Example Templates:**

1. **Extract field from object:**
```
Input: {"user": {"name": "Alice", "age": 30}}
Template: "{{.user.name}}"
Output: "Alice"
```

2. **Transform array:**
```
Input: {"users": [{"name": "Alice"}, {"name": "Bob"}]}
Template: "[{{range $i, $u := .users}}{{if $i}},{{end}}\"{{$u.name}}\"{{end}}]"
Output: ["Alice","Bob"]
```

3. **Combine data:**
```
Input: {"first": "Alice", "last": "Smith"}
Template: "{{.first}} {{.last}}"
Output: "Alice Smith"
```

### Complete TransformTask Implementation

**transform_task.go:**

```go
package tasks

import (
    "bytes"
    "encoding/json"
    "fmt"
    "log/slog"
    "strings"
    "text/template"

    "github.com/[username]/goautomation-hub/internal/engine"
)

// TransformTask implements TaskExecutor for data transformation using Go templates.
type TransformTask struct {
    funcMap template.FuncMap
}

// NewTransformTask creates a new Transform task executor.
func NewTransformTask() *TransformTask {
    return &TransformTask{
        funcMap: createTemplateFuncMap(),
    }
}

// Execute implements the TaskExecutor interface for data transformation.
func (t *TransformTask) Execute(ctx *engine.ExecutionContext, config map[string]interface{}) engine.TaskResult {
    // Extract and validate configuration
    templateStr, ok := config["template"].(string)
    if !ok || templateStr == "" {
        return engine.TaskResult{
            Status: "failed",
            Error:  "missing or invalid 'template' in config",
        }
    }

    // Get data source (optional - defaults to all context)
    var inputData interface{}
    if dataSource, ok := config["data_source"].(string); ok && dataSource != "" {
        // Load specific key from context
        data, exists := ctx.Get(dataSource)
        if !exists {
            slog.Warn("Data source not found in context", "source", dataSource)
            inputData = map[string]interface{}{} // Empty map if not found
        } else {
            inputData = data
        }
    } else {
        // Use entire context
        inputData = ctx.GetAll()
    }

    // Get output format (optional - defaults to "json")
    outputFormat := "json"
    if format, ok := config["output_format"].(string); ok {
        outputFormat = format
    }

    slog.Info("Executing transform", "has_data_source", config["data_source"] != nil, "output_format", outputFormat)

    // Parse and execute template
    tmpl, err := template.New("transform").Funcs(t.funcMap).Parse(templateStr)
    if err != nil {
        slog.Error("Template parsing failed", "error", err)
        return engine.TaskResult{
            Status: "failed",
            Error:  fmt.Sprintf("failed to parse template: %v", err),
        }
    }

    var buf bytes.Buffer
    if err := tmpl.Execute(&buf, inputData); err != nil {
        slog.Error("Template execution failed", "error", err)
        return engine.TaskResult{
            Status: "failed",
            Error:  fmt.Sprintf("failed to execute template: %v", err),
        }
    }

    result := buf.String()

    // Format output
    var output interface{}
    if outputFormat == "json" {
        // Try to parse result as JSON
        var jsonOutput interface{}
        if err := json.Unmarshal([]byte(result), &jsonOutput); err != nil {
            // If not valid JSON, return as string
            slog.Warn("Template output is not valid JSON, returning as string", "error", err)
            output = result
        } else {
            output = jsonOutput
        }
    } else {
        // Return as string
        output = result
    }

    slog.Info("Transform successful")

    return engine.TaskResult{
        Status: "success",
        Output: output,
    }
}

// createTemplateFuncMap creates custom template functions.
func createTemplateFuncMap() template.FuncMap {
    return template.FuncMap{
        // String functions
        "toUpper": strings.ToUpper,
        "toLower": strings.ToLower,
        "trim":    strings.TrimSpace,
        "join": func(sep string, items []interface{}) string {
            strItems := make([]string, len(items))
            for i, item := range items {
                strItems[i] = fmt.Sprint(item)
            }
            return strings.Join(strItems, sep)
        },

        // JSON functions
        "toJSON": func(v interface{}) (string, error) {
            data, err := json.Marshal(v)
            if err != nil {
                return "", err
            }
            return string(data), nil
        },

        // Utility functions
        "default": func(defaultVal, val interface{}) interface{} {
            if val == nil || val == "" {
                return defaultVal
            }
            return val
        },
    }
}

// RegisterTransformTask registers the Transform task executor with the registry.
func RegisterTransformTask(registry *engine.Registry) {
    registry.Register("transform", NewTransformTask())
    slog.Info("Registered Transform task executor")
}
```

### Tech Stack - text/template
[Source: architecture/4-tech-stack.md]

- **Templates:** `text/template` native package
- Purpose: "Motor de transformação de dados"
- No external dependencies required
- Full power of Go templates available

### Template Function Reference

**Built-in Go Template Functions:**
- `{{.field}}` - Access field
- `{{range .array}}...{{end}}` - Iterate
- `{{if .condition}}...{{else}}...{{end}}` - Conditionals
- `{{with .value}}...{{end}}` - Set context
- `{{$var := .value}}` - Variables

**Custom Functions (Story 2.2 adds):**
- `toUpper` - Convert string to uppercase
- `toLower` - Convert string to lowercase
- `trim` - Trim whitespace
- `join` - Join array with separator
- `toJSON` - Convert object to JSON string
- `default` - Provide default value if nil/empty

**Usage Examples:**
```
{{.name | toUpper}}                           → "ALICE"
{{.items | join ", "}}                        → "item1, item2, item3"
{{.user | toJSON}}                            → "{\"name\":\"Alice\"}"
{{.optionalField | default "not provided"}}   → "not provided" (if nil)
```

### Real-World Transformation Examples

**Example 1: Extract Names from User Array**

Input (from HTTP task):
```json
{
  "users": [
    {"id": 1, "name": "Alice", "email": "alice@example.com"},
    {"id": 2, "name": "Bob", "email": "bob@example.com"}
  ]
}
```

Template:
```
[{{range $i, $u := .users}}{{if $i}},{{end}}"{{$u.name}}"{{end}}]
```

Output:
```json
["Alice", "Bob"]
```

**Example 2: Reshape Data Structure**

Input:
```json
{
  "response": {
    "data": {
      "user": {"firstName": "Alice", "lastName": "Smith", "age": 30}
    }
  }
}
```

Template:
```
{"fullName": "{{.response.data.user.firstName}} {{.response.data.user.lastName}}", "age": {{.response.data.user.age}}}
```

Output:
```json
{"fullName": "Alice Smith", "age": 30}
```

**Example 3: Combine Multiple Context Keys**

Context has:
- `user_info`: {"name": "Alice"}
- `order_info`: {"total": 100}

Template (with data_source omitted to access full context):
```
{"customer": "{{.user_info.name}}", "amount": {{.order_info.total}}}
```

Output:
```json
{"customer": "Alice", "amount": 100}
```

**Example 4: Generate CSV from JSON**

Input:
```json
{"users": [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]}
```

Template:
```
name,age
{{range .users}}{{.name}},{{.age}}
{{end}}
```

Output (string format):
```
name,age
Alice,30
Bob,25
```

### File Locations and Structure

Extending `/internal/tasks/` package:

```
internal/tasks/
├── http_task.go           - Story 2.1
├── http_task_test.go      - Story 2.1
├── transform_task.go      - Story 2.2 (NEW)
└── transform_task_test.go - Story 2.2 (NEW)
```

**Package name:** `tasks`

**Import path:** `github.com/[username]/goautomation-hub/internal/tasks`

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Table-driven tests for multiple transformation scenarios
- Co-locate test files with source files

#### Testing Strategy for Story 2.2

**transform_task_test.go:**

```go
package tasks

import (
    "encoding/json"
    "testing"

    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/stretchr/testify/assert"
)

func TestTransformTask_SimpleFieldExtraction(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    // Set up context with data
    ctx.Set("user", map[string]interface{}{
        "name": "Alice",
        "age":  30,
    })

    config := map[string]interface{}{
        "template":      "{{.name}}",
        "data_source":   "user",
        "output_format": "string",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.Equal(t, "Alice", result.Output)
}

func TestTransformTask_ArrayTransformation(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    users := []interface{}{
        map[string]interface{}{"name": "Alice"},
        map[string]interface{}{"name": "Bob"},
        map[string]interface{}{"name": "Charlie"},
    }
    ctx.Set("users_list", map[string]interface{}{"users": users})

    config := map[string]interface{}{
        "template":      `[{{range $i, $u := .users}}{{if $i}},{{end}}"{{$u.name}}"{{end}}]`,
        "data_source":   "users_list",
        "output_format": "json",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    // Parse output as array
    outputArray, ok := result.Output.([]interface{})
    assert.True(t, ok)
    assert.Len(t, outputArray, 3)
    assert.Equal(t, "Alice", outputArray[0])
}

func TestTransformTask_DataReshaping(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    ctx.Set("api_response", map[string]interface{}{
        "data": map[string]interface{}{
            "firstName": "Alice",
            "lastName":  "Smith",
            "age":       30,
        },
    })

    config := map[string]interface{}{
        "template": `{"fullName": "{{.data.firstName}} {{.data.lastName}}", "age": {{.data.age}}}`,
        "data_source":   "api_response",
        "output_format": "json",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    output, ok := result.Output.(map[string]interface{})
    assert.True(t, ok)
    assert.Equal(t, "Alice Smith", output["fullName"])
    assert.Equal(t, float64(30), output["age"]) // JSON numbers are float64
}

func TestTransformTask_CustomFunctions(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    ctx.Set("data", map[string]interface{}{
        "name": "alice",
    })

    config := map[string]interface{}{
        "template":      `{{.name | toUpper}}`,
        "data_source":   "data",
        "output_format": "string",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.Equal(t, "ALICE", result.Output)
}

func TestTransformTask_JoinFunction(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    items := []interface{}{"apple", "banana", "cherry"}
    ctx.Set("items", map[string]interface{}{"list": items})

    config := map[string]interface{}{
        "template":      `{{.list | join ", "}}`,
        "data_source":   "items",
        "output_format": "string",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.Equal(t, "apple, banana, cherry", result.Output)
}

func TestTransformTask_AllContextAccess(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    // Set multiple keys in context
    ctx.Set("user", map[string]interface{}{"name": "Alice"})
    ctx.Set("order", map[string]interface{}{"total": 100})

    config := map[string]interface{}{
        "template": `{"customer": "{{.user.name}}", "amount": {{.order.total}}}`,
        // No data_source - access entire context
        "output_format": "json",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)

    output, ok := result.Output.(map[string]interface{})
    assert.True(t, ok)
    assert.Equal(t, "Alice", output["customer"])
    assert.Equal(t, float64(100), output["amount"])
}

func TestTransformTask_InvalidTemplate(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        "template": `{{.invalid syntax`,
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "failed to parse template")
}

func TestTransformTask_MissingTemplate(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    config := map[string]interface{}{
        // template missing
        "data_source": "something",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "failed", result.Status)
    assert.Contains(t, result.Error, "template")
}

func TestTransformTask_MissingDataSource(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    // Don't set "nonexistent" in context

    config := map[string]interface{}{
        "template":      "{{.name}}",
        "data_source":   "nonexistent",
        "output_format": "string",
    }

    result := task.Execute(ctx, config)

    // Should succeed but with empty data (graceful handling)
    assert.Equal(t, "success", result.Status)
}

func TestTransformTask_DefaultFunction(t *testing.T) {
    task := NewTransformTask()
    ctx := engine.NewExecutionContext()

    ctx.Set("data", map[string]interface{}{
        "name": "",
    })

    config := map[string]interface{}{
        "template":      `{{.name | default "Unknown"}}`,
        "data_source":   "data",
        "output_format": "string",
    }

    result := task.Execute(ctx, config)

    assert.Equal(t, "success", result.Status)
    assert.Equal(t, "Unknown", result.Output)
}
```

**Coverage Target:** >80% overall, aim for 90%+ on TransformTask.Execute()

#### Running Tests

```bash
# Run transform task tests
go test ./internal/tasks/transform_task_test.go -v

# Run all task tests
go test ./internal/tasks/... -v

# Run with coverage
go test ./internal/tasks/... -cover

# Generate coverage report
go test ./internal/tasks/... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Registration and Initialization

**Update cmd/api/main.go:**

```go
package main

import (
    "log/slog"

    "github.com/gin-gonic/gin"
    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/[username]/goautomation-hub/internal/tasks"
)

func main() {
    // Initialize task registry
    registry := engine.NewRegistry()

    // Register task executors
    tasks.RegisterHTTPTask(registry)      // Story 2.1
    tasks.RegisterTransformTask(registry) // Story 2.2
    // Future: tasks.RegisterHTMLParserTask(registry) // Story 2.3

    // Create engine with registry
    executionEngine := engine.NewEngine(registry)

    // Initialize Gin
    router := gin.Default()

    // Health endpoint
    router.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "healthy"})
    })

    // TODO: Add workflow execution endpoints (Epic 3)

    slog.Info("Starting server on :8080")
    router.Run(":8080")
}
```

### Integration with Engine and Story 2.1

**Example Workflow: HTTP Fetch + Transform**

```json
{
  "name": "fetch-and-transform-users",
  "tasks": [
    {
      "id": "fetch_users",
      "type": "http_request",
      "config": {
        "method": "GET",
        "url": "https://jsonplaceholder.typicode.com/users"
      }
    },
    {
      "id": "extract_names",
      "type": "transform",
      "config": {
        "template": "[{{range $i, $u := .body}}{{if $i}},{{end}}\"{{$u.name}}\"{{end}}]",
        "data_source": "fetch_users_result",
        "output_format": "json"
      }
    }
  ]
}
```

**Execution Flow:**
1. `fetch_users` task executes (Story 2.1 HTTP task)
2. HTTP response stored in context as `fetch_users_result`
3. `extract_names` task executes (Story 2.2 Transform task)
4. Transform loads `fetch_users_result` from context
5. Template extracts names from `.body` array
6. Transformed data stored as `extract_names_result`
7. Subsequent tasks can use extracted names

### Success Criteria Summary

To complete this story successfully:
1. ✅ TransformTask struct implements TaskExecutor interface
2. ✅ Uses Go's native `text/template` for data transformation
3. ✅ Supports `template` configuration field
4. ✅ Supports `data_source` configuration (optional, defaults to full context)
5. ✅ Supports `output_format` configuration (json/string)
6. ✅ Custom template functions: toUpper, toLower, trim, join, toJSON, default
7. ✅ Handles template parsing errors gracefully
8. ✅ Handles template execution errors gracefully
9. ✅ Handles missing data sources gracefully
10. ✅ RegisterTransformTask() function available for registry
11. ✅ Registered as "transform" task type
12. ✅ Unit tests passing with >80% coverage
13. ✅ Integration test with HTTP task demonstrates end-to-end workflow

### Error Handling

**Configuration Errors:**
- Return TaskResult with status "failed" for missing template
- Log error using slog

**Template Parsing Errors:**
- Return TaskResult with status "failed" and parse error details
- Log parsing failures

**Template Execution Errors:**
- Return TaskResult with status "failed" and execution error details
- Log execution failures

**Missing Data Source:**
- Log warning but continue with empty data (graceful degradation)
- Don't fail the task - let template handle missing data

### Performance Considerations
[Source: prd/requirements.md - NFR4]

- Template parsing/execution should be fast (<50ms overhead)
- Avoid unnecessary data copying
- Reuse template.FuncMap across executions
- Keep transformations simple for performance

### Comparison with Story 2.1

**Story 2.1 (HTTP Task):**
- Used `text/template` for **string interpolation** within HTTP requests
- Template variables in headers/body: `{{context.auth_token}}`
- Simple string replacement

**Story 2.2 (Transform Task):**
- Uses `text/template` for **data transformation**
- Operates on structured data (maps, arrays)
- Reshapes, extracts, combines data
- More complex template operations (range, conditionals)

**Both use text/template, different purposes!**

### Future Enhancements (Not in this story)

- Template caching for performance
- More custom functions (math, date formatting)
- Support for multiple output destinations
- Validation of transformed output schema

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by the QA Agent after story completion*
