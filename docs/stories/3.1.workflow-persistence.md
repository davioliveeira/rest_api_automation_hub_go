# Story 3.1: Workflow Persistence (PostgreSQL)

## Status
Draft

## Story
**As a** System Administrator,
**I want** to save and load workflow definitions to/from PostgreSQL database,
**so that** workflows persist across server restarts and can be managed through REST API endpoints.

## Acceptance Criteria
1. **AC1:** Endpoints para salvar/carregar definições de workflow.

## Tasks / Subtasks

- [ ] Task 1: Setup database connection and configuration (AC: 1)
  - [ ] Create `internal/repository/db.go` for database connection
  - [ ] Load database configuration from environment variables
  - [ ] Implement connection pooling with pgx/GORM
  - [ ] Add database connection initialization to main.go
  - [ ] Add database health check
  - [ ] Handle connection errors gracefully

- [ ] Task 2: Define Workflow database model (AC: 1)
  - [ ] Create `internal/repository/models.go`
  - [ ] Define `Workflow` struct with GORM tags
  - [ ] Fields: ID (UUID), Name, Definition (JSONB), CreatedAt, UpdatedAt
  - [ ] Add GORM model hooks if needed
  - [ ] Add helper methods for JSON serialization

- [ ] Task 3: Create database migrations (AC: 1)
  - [ ] Create migrations directory structure
  - [ ] Write SQL migration for workflows table creation
  - [ ] Add migration execution logic
  - [ ] Document migration commands
  - [ ] Add rollback capability

- [ ] Task 4: Implement Workflow Repository (AC: 1)
  - [ ] Create `internal/repository/workflow_repository.go`
  - [ ] Implement Repository interface
  - [ ] Create(workflow) - Insert new workflow
  - [ ] GetByID(id) - Retrieve workflow by ID
  - [ ] GetAll() - List all workflows
  - [ ] Update(workflow) - Update existing workflow
  - [ ] Delete(id) - Delete workflow
  - [ ] Handle database errors with descriptive messages

- [ ] Task 5: Implement REST API endpoints (AC: 1)
  - [ ] Create workflow handlers package or add to main.go
  - [ ] POST /workflows - Create new workflow
  - [ ] GET /workflows/:id - Get workflow by ID
  - [ ] GET /workflows - List all workflows
  - [ ] PUT /workflows/:id - Update workflow (optional)
  - [ ] DELETE /workflows/:id - Delete workflow (optional)
  - [ ] Add request validation
  - [ ] Add proper HTTP status codes

- [ ] Task 6: Integrate with existing Engine (AC: 1)
  - [ ] Load workflow from database
  - [ ] Convert database model to engine.WorkflowDefinition
  - [ ] Prepare for POST /workflows/:id/run endpoint (Story 3.2)
  - [ ] Add workflow validation before saving

- [ ] Task 7: Add error handling and logging (AC: 1)
  - [ ] Handle database connection errors
  - [ ] Handle duplicate workflow names
  - [ ] Handle invalid JSON definitions
  - [ ] Handle not found errors (404)
  - [ ] Log all database operations using slog
  - [ ] Return proper error responses to API clients

- [ ] Task 8: Write comprehensive unit tests (Testing requirement)
  - [ ] Create repository tests with database mocks
  - [ ] Test Create workflow
  - [ ] Test GetByID workflow
  - [ ] Test GetAll workflows
  - [ ] Test Update/Delete workflows
  - [ ] Test error scenarios (duplicate, not found, invalid data)
  - [ ] Ensure >80% test coverage

- [ ] Task 9: Write integration tests (Testing requirement)
  - [ ] Test API endpoints with test database
  - [ ] Test POST /workflows with valid workflow
  - [ ] Test GET /workflows/:id returns saved workflow
  - [ ] Test GET /workflows lists workflows
  - [ ] Test error responses (invalid JSON, not found)
  - [ ] Use httptest for API testing

- [ ] Task 10: Update Docker Compose and documentation
  - [ ] Verify postgres service configuration
  - [ ] Add database initialization scripts if needed
  - [ ] Update README with database setup instructions
  - [ ] Document API endpoints with examples
  - [ ] Add migration instructions

## Dev Notes

### Epic Foundation Context

**Epic 1 - Foundation (Complete):**
- **Story 1.1:** Gin API server at `cmd/api/main.go`, Docker Compose with `postgres` service already configured, environment variables support
- **Story 1.2:** `WorkflowDefinition` struct defined in `internal/engine/types.go`
- **Story 1.3:** Engine can execute workflows in-memory

**Epic 2 - Task Nodes (Complete):**
- **Stories 2.1-2.3:** HTTP, Transform, HTML Parser tasks fully implemented
- Engine can execute complex workflows
- **Gap:** Workflows only exist in-memory, no persistence

**Story 3.1 Adds Persistence:**
- Save workflow definitions to PostgreSQL
- Load workflows from database for execution
- Manage workflows via REST API
- Foundation for Story 3.2 (execution logging)

### Acceptance Criteria Breakdown

**AC1: "Endpoints para salvar/carregar definições de workflow"**

This means:
- **Salvar (Save):** POST /workflows endpoint to create/save workflows
- **Carregar (Load):** GET /workflows/:id endpoint to retrieve workflows
- Additional endpoints: GET /workflows (list), PUT/DELETE for management

### Data Model - Workflow Entity
[Source: architecture/5-data-models.md]

**Workflow:** "Define o nome e o JSON da estrutura de tarefas (`definition`)."

**Database Schema:**
```sql
CREATE TABLE workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    definition JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_workflows_name ON workflows(name);
```

**GORM Model:**
```go
type Workflow struct {
    ID         uuid.UUID      `gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    Name       string         `gorm:"type:varchar(255);not null;uniqueIndex"`
    Definition datatypes.JSON `gorm:"type:jsonb;not null"`
    CreatedAt  time.Time      `gorm:"autoCreateTime"`
    UpdatedAt  time.Time      `gorm:"autoUpdateTime"`
}
```

### Tech Stack - Database
[Source: architecture/4-tech-stack.md]

- **Database:** PostgreSQL 15+
- **Driver/ORM:** pgx v5 / GORM v1.25
- **Purpose:** Relational persistence with JSONB support

**Why GORM:**
- Productivity (ORM features)
- JSONB support for workflow definitions
- Migration support
- Connection pooling

**Why pgx (alternative):**
- Performance (native PostgreSQL driver)
- Lower level control
- For this story, **GORM recommended** for productivity

### Design Pattern - Repository Pattern
[Source: architecture/3-high-level-architecture.md]

**Repository Pattern:** "Abstração da camada de persistência (PostgreSQL)"

**Benefits:**
- Decouples database from business logic
- Easier testing (mock repository)
- Swappable data sources
- Clean separation of concerns

**Repository Interface:**
```go
type WorkflowRepository interface {
    Create(workflow *Workflow) error
    GetByID(id uuid.UUID) (*Workflow, error)
    GetAll() ([]*Workflow, error)
    Update(workflow *Workflow) error
    Delete(id uuid.UUID) error
}
```

### REST API Spec
[Source: architecture/9-rest-api-spec.md]

**POST /workflows:** "Registo de novos fluxos"

**Story 3.1 Implements:**
- `POST /workflows` - Create workflow
- `GET /workflows/:id` - Retrieve workflow
- `GET /workflows` - List all workflows

**Future (Story 3.2):**
- `POST /workflows/:id/run` - Execute workflow
- `GET /executions/:id` - Monitor execution

### Complete Database Layer Implementation

**internal/repository/db.go:**

```go
package repository

import (
    "fmt"
    "log/slog"
    "os"
    "time"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

// DB holds the database connection
var DB *gorm.DB

// InitDB initializes the database connection
func InitDB() error {
    // Load configuration from environment
    host := os.Getenv("DB_HOST")
    port := os.Getenv("DB_PORT")
    user := os.Getenv("DB_USER")
    password := os.Getenv("DB_PASSWORD")
    dbname := os.Getenv("DB_NAME")

    // Build connection string
    dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
        host, port, user, password, dbname)

    slog.Info("Connecting to database", "host", host, "port", port, "dbname", dbname)

    // Configure GORM
    config := &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
        NowFunc: func() time.Time {
            return time.Now().UTC()
        },
    }

    // Connect to database
    db, err := gorm.Open(postgres.Open(dsn), config)
    if err != nil {
        return fmt.Errorf("failed to connect to database: %w", err)
    }

    // Configure connection pool
    sqlDB, err := db.DB()
    if err != nil {
        return fmt.Errorf("failed to get database instance: %w", err)
    }

    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)

    // Test connection
    if err := sqlDB.Ping(); err != nil {
        return fmt.Errorf("failed to ping database: %w", err)
    }

    DB = db
    slog.Info("Database connection established successfully")

    return nil
}

// AutoMigrate runs database migrations
func AutoMigrate() error {
    slog.Info("Running database migrations")

    if err := DB.AutoMigrate(&Workflow{}); err != nil {
        return fmt.Errorf("migration failed: %w", err)
    }

    slog.Info("Database migrations completed successfully")
    return nil
}

// CloseDB closes the database connection
func CloseDB() error {
    sqlDB, err := DB.DB()
    if err != nil {
        return err
    }
    return sqlDB.Close()
}

// HealthCheck checks database connectivity
func HealthCheck() error {
    sqlDB, err := DB.DB()
    if err != nil {
        return err
    }
    return sqlDB.Ping()
}
```

**internal/repository/models.go:**

```go
package repository

import (
    "time"

    "github.com/google/uuid"
    "gorm.io/datatypes"
    "gorm.io/gorm"
)

// Workflow represents a workflow definition in the database
type Workflow struct {
    ID         uuid.UUID      `gorm:"type:uuid;primary_key" json:"id"`
    Name       string         `gorm:"type:varchar(255);not null;uniqueIndex" json:"name"`
    Definition datatypes.JSON `gorm:"type:jsonb;not null" json:"definition"`
    CreatedAt  time.Time      `gorm:"autoCreateTime" json:"created_at"`
    UpdatedAt  time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
}

// BeforeCreate GORM hook to generate UUID
func (w *Workflow) BeforeCreate(tx *gorm.DB) error {
    if w.ID == uuid.Nil {
        w.ID = uuid.New()
    }
    return nil
}

// TableName specifies the table name
func (Workflow) TableName() string {
    return "workflows"
}
```

**internal/repository/workflow_repository.go:**

```go
package repository

import (
    "errors"
    "fmt"
    "log/slog"

    "github.com/google/uuid"
    "gorm.io/gorm"
)

// WorkflowRepository interface defines workflow data operations
type WorkflowRepository interface {
    Create(workflow *Workflow) error
    GetByID(id uuid.UUID) (*Workflow, error)
    GetByName(name string) (*Workflow, error)
    GetAll() ([]*Workflow, error)
    Update(workflow *Workflow) error
    Delete(id uuid.UUID) error
}

// GormWorkflowRepository implements WorkflowRepository using GORM
type GormWorkflowRepository struct {
    db *gorm.DB
}

// NewWorkflowRepository creates a new workflow repository
func NewWorkflowRepository(db *gorm.DB) WorkflowRepository {
    return &GormWorkflowRepository{db: db}
}

// Create inserts a new workflow
func (r *GormWorkflowRepository) Create(workflow *Workflow) error {
    slog.Info("Creating workflow", "name", workflow.Name)

    if err := r.db.Create(workflow).Error; err != nil {
        slog.Error("Failed to create workflow", "error", err, "name", workflow.Name)
        return fmt.Errorf("failed to create workflow: %w", err)
    }

    slog.Info("Workflow created successfully", "id", workflow.ID, "name", workflow.Name)
    return nil
}

// GetByID retrieves a workflow by ID
func (r *GormWorkflowRepository) GetByID(id uuid.UUID) (*Workflow, error) {
    slog.Info("Retrieving workflow by ID", "id", id)

    var workflow Workflow
    if err := r.db.Where("id = ?", id).First(&workflow).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            slog.Warn("Workflow not found", "id", id)
            return nil, fmt.Errorf("workflow not found: %s", id)
        }
        slog.Error("Failed to retrieve workflow", "error", err, "id", id)
        return nil, fmt.Errorf("failed to retrieve workflow: %w", err)
    }

    slog.Info("Workflow retrieved successfully", "id", id, "name", workflow.Name)
    return &workflow, nil
}

// GetByName retrieves a workflow by name
func (r *GormWorkflowRepository) GetByName(name string) (*Workflow, error) {
    slog.Info("Retrieving workflow by name", "name", name)

    var workflow Workflow
    if err := r.db.Where("name = ?", name).First(&workflow).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            slog.Warn("Workflow not found", "name", name)
            return nil, fmt.Errorf("workflow not found: %s", name)
        }
        slog.Error("Failed to retrieve workflow", "error", err, "name", name)
        return nil, fmt.Errorf("failed to retrieve workflow: %w", err)
    }

    slog.Info("Workflow retrieved successfully", "name", name, "id", workflow.ID)
    return &workflow, nil
}

// GetAll retrieves all workflows
func (r *GormWorkflowRepository) GetAll() ([]*Workflow, error) {
    slog.Info("Retrieving all workflows")

    var workflows []*Workflow
    if err := r.db.Order("created_at DESC").Find(&workflows).Error; err != nil {
        slog.Error("Failed to retrieve workflows", "error", err)
        return nil, fmt.Errorf("failed to retrieve workflows: %w", err)
    }

    slog.Info("Workflows retrieved successfully", "count", len(workflows))
    return workflows, nil
}

// Update updates an existing workflow
func (r *GormWorkflowRepository) Update(workflow *Workflow) error {
    slog.Info("Updating workflow", "id", workflow.ID, "name", workflow.Name)

    if err := r.db.Save(workflow).Error; err != nil {
        slog.Error("Failed to update workflow", "error", err, "id", workflow.ID)
        return fmt.Errorf("failed to update workflow: %w", err)
    }

    slog.Info("Workflow updated successfully", "id", workflow.ID)
    return nil
}

// Delete deletes a workflow by ID
func (r *GormWorkflowRepository) Delete(id uuid.UUID) error {
    slog.Info("Deleting workflow", "id", id)

    result := r.db.Delete(&Workflow{}, id)
    if result.Error != nil {
        slog.Error("Failed to delete workflow", "error", result.Error, "id", id)
        return fmt.Errorf("failed to delete workflow: %w", result.Error)
    }

    if result.RowsAffected == 0 {
        slog.Warn("Workflow not found for deletion", "id", id)
        return fmt.Errorf("workflow not found: %s", id)
    }

    slog.Info("Workflow deleted successfully", "id", id)
    return nil
}
```

### API Handlers Implementation

**cmd/api/handlers.go (or add to main.go):**

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
    "github.com/[username]/goautomation-hub/internal/repository"
    "gorm.io/datatypes"
)

// CreateWorkflowRequest represents the request body for creating a workflow
type CreateWorkflowRequest struct {
    Name       string                 `json:"name" binding:"required"`
    Definition map[string]interface{} `json:"definition" binding:"required"`
}

// handleCreateWorkflow handles POST /workflows
func handleCreateWorkflow(repo repository.WorkflowRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req CreateWorkflowRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body", "details": err.Error()})
            return
        }

        // Convert definition to JSONB
        defJSON, err := datatypes.JSON(req.Definition).MarshalJSON()
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid workflow definition"})
            return
        }

        workflow := &repository.Workflow{
            Name:       req.Name,
            Definition: defJSON,
        }

        if err := repo.Create(workflow); err != nil {
            // Check for duplicate name
            if contains(err.Error(), "duplicate") || contains(err.Error(), "unique") {
                c.JSON(http.StatusConflict, gin.H{"error": "Workflow with this name already exists"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create workflow"})
            return
        }

        c.JSON(http.StatusCreated, workflow)
    }
}

// handleGetWorkflow handles GET /workflows/:id
func handleGetWorkflow(repo repository.WorkflowRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := uuid.Parse(idParam)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid workflow ID"})
            return
        }

        workflow, err := repo.GetByID(id)
        if err != nil {
            if contains(err.Error(), "not found") {
                c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
            return
        }

        c.JSON(http.StatusOK, workflow)
    }
}

// handleListWorkflows handles GET /workflows
func handleListWorkflows(repo repository.WorkflowRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        workflows, err := repo.GetAll()
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflows"})
            return
        }

        c.JSON(http.StatusOK, workflows)
    }
}

// handleUpdateWorkflow handles PUT /workflows/:id
func handleUpdateWorkflow(repo repository.WorkflowRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := uuid.Parse(idParam)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid workflow ID"})
            return
        }

        var req CreateWorkflowRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
            return
        }

        // Get existing workflow
        workflow, err := repo.GetByID(id)
        if err != nil {
            if contains(err.Error(), "not found") {
                c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve workflow"})
            return
        }

        // Update fields
        workflow.Name = req.Name
        defJSON, _ := datatypes.JSON(req.Definition).MarshalJSON()
        workflow.Definition = defJSON

        if err := repo.Update(workflow); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update workflow"})
            return
        }

        c.JSON(http.StatusOK, workflow)
    }
}

// handleDeleteWorkflow handles DELETE /workflows/:id
func handleDeleteWorkflow(repo repository.WorkflowRepository) gin.HandlerFunc {
    return func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := uuid.Parse(idParam)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid workflow ID"})
            return
        }

        if err := repo.Delete(id); err != nil {
            if contains(err.Error(), "not found") {
                c.JSON(http.StatusNotFound, gin.H{"error": "Workflow not found"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete workflow"})
            return
        }

        c.JSON(http.StatusNoContent, nil)
    }
}

// Helper function
func contains(s, substr string) bool {
    return len(s) >= len(substr) && (s == substr || len(s) > len(substr) && (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr))
}
```

### Updated main.go

**cmd/api/main.go:**

```go
package main

import (
    "log"
    "log/slog"
    "os"

    "github.com/gin-gonic/gin"
    "github.com/[username]/goautomation-hub/internal/engine"
    "github.com/[username]/goautomation-hub/internal/repository"
    "github.com/[username]/goautomation-hub/internal/tasks"
)

func main() {
    // Initialize database
    if err := repository.InitDB(); err != nil {
        log.Fatalf("Failed to initialize database: %v", err)
    }
    defer repository.CloseDB()

    // Run migrations
    if err := repository.AutoMigrate(); err != nil {
        log.Fatalf("Failed to run migrations: %v", err)
    }

    // Initialize repository
    workflowRepo := repository.NewWorkflowRepository(repository.DB)

    // Initialize task registry
    registry := engine.NewRegistry()
    tasks.RegisterHTTPTask(registry)
    tasks.RegisterTransformTask(registry)
    tasks.RegisterHTMLParserTask(registry)

    // Create engine
    executionEngine := engine.NewEngine(registry)

    // Initialize Gin
    router := gin.Default()

    // Health endpoint (includes database check)
    router.GET("/health", func(c *gin.Context) {
        dbHealthy := repository.HealthCheck() == nil
        if !dbHealthy {
            c.JSON(500, gin.H{"status": "unhealthy", "database": "disconnected"})
            return
        }
        c.JSON(200, gin.H{"status": "healthy", "database": "connected"})
    })

    // Workflow endpoints
    router.POST("/workflows", handleCreateWorkflow(workflowRepo))
    router.GET("/workflows/:id", handleGetWorkflow(workflowRepo))
    router.GET("/workflows", handleListWorkflows(workflowRepo))
    router.PUT("/workflows/:id", handleUpdateWorkflow(workflowRepo))
    router.DELETE("/workflows/:id", handleDeleteWorkflow(workflowRepo))

    // TODO: Add execution endpoints (Story 3.2)
    // POST /workflows/:id/run
    // GET /executions/:id

    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }

    slog.Info("Starting server", "port", port)
    if err := router.Run(":" + port); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }
}
```

### Environment Variables

**Required .env variables (already in Story 1.1):**
```
DB_HOST=postgres
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=goautomation
PORT=8080
```

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Mock database for unit tests
- Use test database for integration tests

#### Testing Strategy for Story 3.1

**Repository Unit Tests (with mocks):**

Use `github.com/DATA-DOG/go-sqlmock` for database mocking:

```go
// internal/repository/workflow_repository_test.go
package repository

import (
    "testing"
    "time"

    "github.com/DATA-DOG/go-sqlmock"
    "github.com/google/uuid"
    "github.com/stretchr/testify/assert"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

func setupMockDB(t *testing.T) (*gorm.DB, sqlmock.Sqlmock) {
    db, mock, err := sqlmock.New()
    assert.NoError(t, err)

    gormDB, err := gorm.Open(postgres.New(postgres.Config{
        Conn: db,
    }), &gorm.Config{})
    assert.NoError(t, err)

    return gormDB, mock
}

func TestWorkflowRepository_Create(t *testing.T) {
    db, mock := setupMockDB(t)
    repo := NewWorkflowRepository(db)

    workflow := &Workflow{
        ID:         uuid.New(),
        Name:       "test-workflow",
        Definition: []byte(`{"name":"test"}`),
    }

    mock.ExpectBegin()
    mock.ExpectExec("INSERT INTO \"workflows\"").
        WillReturnResult(sqlmock.NewResult(1, 1))
    mock.ExpectCommit()

    err := repo.Create(workflow)
    assert.NoError(t, err)
    assert.NoError(t, mock.ExpectationsWereMet())
}

// Additional test cases: GetByID, GetAll, Update, Delete, error scenarios
```

**API Integration Tests:**

```go
// cmd/api/handlers_test.go
package main

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
)

func TestCreateWorkflow_Success(t *testing.T) {
    // Setup test database
    // Setup router with handlers
    // Create test workflow request
    reqBody := CreateWorkflowRequest{
        Name: "test-workflow",
        Definition: map[string]interface{}{
            "name":  "test",
            "tasks": []interface{}{},
        },
    }

    bodyBytes, _ := json.Marshal(reqBody)
    req := httptest.NewRequest(http.MethodPost, "/workflows", bytes.NewReader(bodyBytes))
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)

    assert.Equal(t, http.StatusCreated, w.Code)

    var response repository.Workflow
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.Equal(t, "test-workflow", response.Name)
    assert.NotEqual(t, uuid.Nil, response.ID)
}

// Additional test cases: GET, PUT, DELETE, error responses
```

**Coverage Target:** >80% overall

#### Running Tests

```bash
# Run repository tests
go test ./internal/repository/... -v

# Run API tests
go test ./cmd/api/... -v

# Run with coverage
go test ./... -cover

# Integration tests with test database
DATABASE_URL=test_db go test ./cmd/api/... -tags=integration
```

### Success Criteria Summary

To complete this story successfully:
1. ✅ Database connection setup with pgx/GORM
2. ✅ Workflow model defined with GORM tags and UUID support
3. ✅ Database migrations for workflows table
4. ✅ Repository interface and implementation (CRUD operations)
5. ✅ POST /workflows endpoint (create workflow)
6. ✅ GET /workflows/:id endpoint (retrieve workflow)
7. ✅ GET /workflows endpoint (list workflows)
8. ✅ PUT /workflows/:id endpoint (update workflow)
9. ✅ DELETE /workflows/:id endpoint (delete workflow)
10. ✅ Error handling (duplicate names, not found, invalid JSON)
11. ✅ Database health check in /health endpoint
12. ✅ Integration with existing Gin server
13. ✅ Unit tests passing with >80% coverage
14. ✅ Integration tests with API endpoints
15. ✅ Documentation updated (README, API examples)

### Error Handling

**Database Errors:**
- Connection failures: Log and return 500
- Duplicate workflow names: Return 409 Conflict
- Not found: Return 404 with message

**Validation Errors:**
- Missing required fields: Return 400 Bad Request
- Invalid UUID: Return 400
- Invalid JSON definition: Return 400

**All errors logged with slog for debugging**

### Performance Considerations

- Connection pooling configured (10 idle, 100 max)
- JSONB for efficient JSON storage and querying
- Index on workflow name for fast lookups
- Database health checks for monitoring

### Migration Strategy

**Auto-migration (Development):**
```go
repository.AutoMigrate()
```

**Manual migrations (Production):**
```sql
-- migrations/001_create_workflows.up.sql
CREATE TABLE workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL UNIQUE,
    definition JSONB NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_workflows_name ON workflows(name);
```

### API Examples

**Create Workflow:**
```bash
curl -X POST http://localhost:8080/workflows \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-workflow",
    "definition": {
      "name": "my-workflow",
      "tasks": [
        {
          "id": "fetch",
          "type": "http_request",
          "config": {
            "method": "GET",
            "url": "https://api.example.com/data"
          }
        }
      ]
    }
  }'
```

**Get Workflow:**
```bash
curl http://localhost:8080/workflows/{workflow-id}
```

**List Workflows:**
```bash
curl http://localhost:8080/workflows
```

### Integration with Story 3.2

Story 3.2 will add:
- POST /workflows/:id/run endpoint (execute workflow from database)
- Execution and TaskLog tables
- Execution logging

Story 3.1 provides the foundation by:
- Storing workflow definitions
- Providing workflow retrieval for execution
- Establishing database connection and repository pattern

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by the QA Agent after story completion*
