# Story 1.2: Execution Engine & Context

## Status
Ready for Review

## Story
**As a** Developer,
**I want** to implement a thread-safe ExecutionContext and a sequential task execution engine,
**so that** the system can orchestrate workflows by processing tasks in order and sharing data between them in a controlled manner.

## Acceptance Criteria
1. **AC1:** Struct `ExecutionContext` implementada com métodos Thread-safe.
2. **AC2:** Loop sequencial que percorre a lista de tarefas JSON.

## Tasks / Subtasks

- [x] Task 1: Implement ExecutionContext struct with thread-safe operations (AC: 1)
  - [x] Create `internal/engine/context.go` file
  - [x] Define `ExecutionContext` struct with internal map for key-value storage
  - [x] Implement `Set(key string, value interface{})` method with mutex lock
  - [x] Implement `Get(key string) (interface{}, bool)` method with mutex lock
  - [x] Implement `GetAll() map[string]interface{}` method returning snapshot
  - [x] Implement `Clear()` method for context reset
  - [x] Add sync.RWMutex for thread-safe concurrent access

- [x] Task 2: Define Workflow and Task JSON structures (AC: 2)
  - [x] Create `internal/engine/types.go` file
  - [x] Define `WorkflowDefinition` struct matching JSON structure
  - [x] Define `Task` struct with fields: Type, ID, Config, Retry
  - [x] Add JSON tags for proper marshaling/unmarshaling
  - [x] Define `TaskResult` struct with Status, Output, Error fields

- [x] Task 3: Implement Execution Engine with sequential loop (AC: 2)
  - [x] Create `internal/engine/engine.go` file
  - [x] Define `Engine` struct with ExecutionContext field
  - [x] Implement `NewEngine()` constructor initializing empty context
  - [x] Implement `Execute(workflow WorkflowDefinition)` method
  - [x] Add sequential for-loop iterating through workflow tasks array
  - [x] Log each task execution start using `slog`
  - [x] Add placeholder for task executor invocation (will be implemented in Story 1.3)
  - [x] Return aggregated execution result

- [x] Task 4: Add logging and error handling
  - [x] Use Go's native `log/slog` for structured logging
  - [x] Log context initialization
  - [x] Log each task processing with task ID and type
  - [x] Log execution completion with status
  - [x] Handle and propagate errors from task execution

- [x] Task 5: Write comprehensive unit tests (Testing requirement)
  - [x] Create `internal/engine/context_test.go`
    - [x] Test Set/Get operations
    - [x] Test concurrent access safety (goroutines)
    - [x] Test GetAll returns proper snapshot
    - [x] Test Clear functionality
  - [x] Create `internal/engine/engine_test.go`
    - [x] Test engine initialization
    - [x] Test sequential task processing order
    - [x] Test workflow with multiple tasks executes in sequence
    - [x] Test context is shared across tasks
  - [x] Ensure >80% test coverage

- [x] Task 6: Integration with API layer (preparation for Story 1.3)
  - [x] Define package exports and public interfaces
  - [x] Ensure engine can be instantiated from cmd/api layer
  - [x] Document usage examples in code comments

## Dev Notes

### Previous Story Context (Story 1.1)

Story 1.1 established:
- Standard Go Project Layout with `/cmd`, `/internal`, `/pkg` structure
- Gin API server foundation at `cmd/api/main.go`
- Docker Compose infrastructure (app + postgres)
- Health check endpoint as API foundation
- Testing requirements: 80% coverage with Go's native testing framework

**Important for Story 1.2:** The Gin server and project structure are ready. This story focuses on implementing the core engine logic in the `/internal` package, which will later be called from the API handlers.

### Functional Requirements Context
[Source: prd/requirements.md - FR2, FR3]

- **FR2:** "O motor deve processar tarefas de forma sequencial conforme a ordem definida no array do JSON."
  - Tasks must execute in the exact order they appear in the JSON workflow definition
  - No parallel execution at this stage

- **FR3:** "O sistema deve manter um `ExecutionContext` isolado por execução para partilha de dados entre nós."
  - Each workflow execution gets its own isolated ExecutionContext instance
  - Context acts as shared memory between tasks within a single execution
  - Data set by one task can be retrieved by subsequent tasks

### Non-Functional Requirements
[Source: prd/requirements.md - NFR4]

- **NFR4:** "Overhead de orquestração interno inferior a 50ms por transição de nó."
  - Performance constraint: transitions between tasks should be <50ms
  - ExecutionContext operations (Get/Set) must be highly efficient
  - Use RWMutex for optimal read performance (multiple readers, single writer)

### Architecture - ExecutionContext Component
[Source: architecture/6-components.md]

**ExecutionContext Definition:**
- "Mapa thread-safe para partilha de dados inter-tasks"
- In-memory key-value store
- Thread-safety is critical for potential future parallel task support
- Scoped to a single workflow execution

**Implementation Guidance:**
- Use `sync.RWMutex` for thread-safe access
- Internal storage: `map[string]interface{}` for flexibility
- Lock granularity: Lock only during map operations, not during task execution

### Architecture - Execution Engine Component
[Source: architecture/6-components.md]

**Execution Engine Definition:**
- "Loop de orquestração e lógica de retry"
- Orchestrates task execution flow
- Manages ExecutionContext lifecycle
- (Retry logic will be added in future stories per FR8)

**Implementation Approach:**
- Simple for-loop iterating through tasks array
- Initialize context before loop starts
- Pass context to each task executor
- Collect and aggregate results

### Data Models
[Source: architecture/5-data-models.md]

While database persistence happens in Epic 3, this story needs to understand the data structures:

**Workflow:**
- Name: string
- Definition: JSON structure containing tasks array

**Execution:**
- Status: string (pending, running, completed, failed)
- Context Snapshot: JSONB representation of ExecutionContext state

**TaskLog:**
- Will be implemented in Epic 3, but engine should be designed with logging in mind

### Core Workflow - Happy Path Execution
[Source: architecture/8-core-workflows.md]

The sequence diagram shows this flow:
```
Client -> Engine: POST /run
Engine -> ExecutionContext: Init Context
Loop Tasks:
    Engine -> Task Executor: Run Task
    Task Executor -> Engine: TaskResult(Output)
    Engine -> ExecutionContext: Update Context
    Engine -> DB: Log Task (Epic 3)
End Loop
Engine -> DB: Save Final Snapshot (Epic 3)
Engine -> Client: 202 Accepted
```

**Story 1.2 implements:**
1. ExecutionContext initialization
2. Sequential task loop
3. Context update mechanism (Set/Get)

**Story 1.3 will add:**
- Task Executor interface and registry
- Actual task execution logic

**Epic 3 will add:**
- Database logging
- Snapshot persistence

### High-Level Architecture Context
[Source: architecture/3-high-level-architecture.md]

**Architectural Pattern: Monólito Modular**
- Engine is a core module in the `/internal` package
- Registry Pattern will be introduced in Story 1.3 for task discovery
- ExecutionContext is intentionally in-memory (no database coupling at this layer)

**Design Patterns:**
- **Strategy Pattern (future):** Task executors implement common interface
- At this stage, focus on the execution loop infrastructure

### Tech Stack
[Source: architecture/4-tech-stack.md]

- **Language:** Go 1.21+ (use native `sync` package for thread-safety)
- **Logging:** Native `log/slog` for structured logging
- **Testing:** Native `testing` package with table-driven tests

### File Locations and Structure

Based on Standard Go Layout and internal package organization:

```
internal/engine/
├── context.go       - ExecutionContext implementation
├── context_test.go  - ExecutionContext tests
├── engine.go        - Engine orchestration logic
├── engine_test.go   - Engine tests
└── types.go         - Workflow, Task, TaskResult structs
```

**Package name:** `engine`

**Import path:** `github.com/[username]/goautomation-hub/internal/engine`

### Code Structure Guidance

**context.go structure:**
```go
package engine

import "sync"

type ExecutionContext struct {
    mu    sync.RWMutex
    data  map[string]interface{}
}

func NewExecutionContext() *ExecutionContext { ... }
func (ctx *ExecutionContext) Set(key string, value interface{}) { ... }
func (ctx *ExecutionContext) Get(key string) (interface{}, bool) { ... }
func (ctx *ExecutionContext) GetAll() map[string]interface{} { ... }
func (ctx *ExecutionContext) Clear() { ... }
```

**types.go structure:**
```go
package engine

type WorkflowDefinition struct {
    Name  string `json:"name"`
    Tasks []Task `json:"tasks"`
}

type Task struct {
    ID     string                 `json:"id"`
    Type   string                 `json:"type"`
    Config map[string]interface{} `json:"config"`
}

type TaskResult struct {
    Status string      `json:"status"` // "success", "failed"
    Output interface{} `json:"output"`
    Error  string      `json:"error,omitempty"`
}
```

**engine.go structure:**
```go
package engine

import "log/slog"

type Engine struct {
    context *ExecutionContext
}

func NewEngine() *Engine { ... }

func (e *Engine) Execute(workflow WorkflowDefinition) error {
    slog.Info("Starting workflow execution", "workflow", workflow.Name)

    for i, task := range workflow.Tasks {
        slog.Info("Processing task", "index", i, "id", task.ID, "type", task.Type)

        // Placeholder: Story 1.3 will add actual task execution
        // For now, just demonstrate sequential processing

        // Update context with task output (simulated)
        e.context.Set(task.ID+"_result", "placeholder")
    }

    slog.Info("Workflow execution completed", "workflow", workflow.Name)
    return nil
}
```

### Testing

#### Testing Standards
[Source: architecture/2-starter-template-ou-projeto-existente.md]

- Minimum 80% test coverage
- Use Go's native `testing` package
- Table-driven tests for multiple scenarios
- Mock external dependencies (none in this story)
- Co-locate test files with source files

#### Testing Strategy for Story 1.2

**context_test.go tests:**

1. **Test Basic Operations:**
   - Set a value, verify Get returns it
   - Get non-existent key returns false
   - GetAll returns complete snapshot

2. **Test Thread Safety:**
```go
func TestExecutionContext_ConcurrentAccess(t *testing.T) {
    ctx := NewExecutionContext()
    var wg sync.WaitGroup

    // Launch multiple goroutines writing to context
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            ctx.Set(fmt.Sprintf("key%d", id), id)
        }(i)
    }

    // Launch multiple goroutines reading from context
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            _, _ = ctx.Get(fmt.Sprintf("key%d", id))
        }(i)
    }

    wg.Wait()
    // No race conditions should occur
}
```

3. **Test Clear Functionality:**
   - Set multiple values
   - Call Clear()
   - Verify GetAll returns empty map

**engine_test.go tests:**

1. **Test Engine Initialization:**
   - NewEngine() returns non-nil engine
   - Engine has initialized ExecutionContext

2. **Test Sequential Execution:**
```go
func TestEngine_SequentialExecution(t *testing.T) {
    engine := NewEngine()

    workflow := WorkflowDefinition{
        Name: "test-workflow",
        Tasks: []Task{
            {ID: "task1", Type: "test", Config: map[string]interface{}{}},
            {ID: "task2", Type: "test", Config: map[string]interface{}{}},
            {ID: "task3", Type: "test", Config: map[string]interface{}{}},
        },
    }

    err := engine.Execute(workflow)
    assert.NoError(t, err)

    // Verify all tasks were processed
    // (In Story 1.3, we'll verify actual execution)
}
```

3. **Test Context Persistence Across Tasks:**
   - Task 1 sets a value in context
   - Task 2 retrieves that value
   - Verify value is accessible

4. **Test Empty Workflow:**
   - Execute workflow with zero tasks
   - Should complete successfully without errors

**Coverage Target:**
- ExecutionContext: 100% (simple data structure)
- Engine: >80% (focus on loop logic and initialization)

#### Running Tests

```bash
# Run all engine tests
go test ./internal/engine/... -v

# Run with coverage
go test ./internal/engine/... -cover

# Generate coverage report
go test ./internal/engine/... -coverprofile=coverage.out
go tool cover -html=coverage.out
```

### Integration Notes

**Preparation for Story 1.3:**
- Engine needs to accept TaskExecutor interface (to be defined in 1.3)
- Registry pattern will be introduced for task type lookup
- Current placeholder logic will be replaced with actual executor calls

**API Integration (future):**
- POST /workflows/:id/run will call `Engine.Execute()`
- ExecutionContext snapshot will be serialized to JSON
- Async execution will wrap Engine.Execute() in goroutine

### Success Criteria Summary

To complete this story successfully:
1. ✅ ExecutionContext struct with thread-safe Set/Get/GetAll/Clear methods
2. ✅ No race conditions when accessed concurrently (verified by tests)
3. ✅ Engine struct with Execute method processing tasks sequentially
4. ✅ WorkflowDefinition and Task structs properly defined with JSON tags
5. ✅ Structured logging using `slog` throughout execution flow
6. ✅ Unit tests passing with >80% coverage
7. ✅ Sequential task processing order preserved (verified by tests)
8. ✅ Code follows Go idioms and best practices

### Performance Considerations
[Source: prd/requirements.md - NFR4]

- Keep ExecutionContext operations under 50ms
- Use RWMutex for better read performance (multiple concurrent reads)
- Avoid unnecessary copying of context data
- Profile with `go test -bench` if needed

### Error Handling

At this stage:
- Return errors from Engine.Execute() if workflow is invalid
- Log errors using slog
- Don't panic - return descriptive errors instead
- (Retry logic will be added in future stories per FR8)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 1.0 | Initial story draft created | Bob (SM) |
| 2026-01-17 | 1.1 | Story implementation completed - all tasks done | James (Dev) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - implementation completed without issues

### Completion Notes List
- Successfully implemented thread-safe ExecutionContext with RWMutex for optimal read performance
- ExecutionContext supports Set, Get, GetAll (snapshot), and Clear operations
- All concurrent access tests pass with no race conditions (verified with -race flag)
- Defined WorkflowDefinition, Task, and TaskResult structs with proper JSON tags
- Implemented Engine with sequential task execution loop
- Structured logging using Go's native slog package throughout execution flow
- Placeholder task execution logic in place for Story 1.3 integration
- Comprehensive unit tests: 20 test cases across context and engine
- Test coverage: 100% on all engine package code
- Race detector: No race conditions detected in concurrent tests
- All tests passing (20/20) with proper isolation between engine instances
- Code follows Go idioms: exported types capitalized, unexported fields, proper error handling
- Ready for Story 1.3 to add TaskExecutor interface and Registry pattern

### File List
**Created:**
- `internal/engine/context.go` - ExecutionContext implementation with thread-safe operations (57 lines)
- `internal/engine/types.go` - WorkflowDefinition, Task, and TaskResult structs (20 lines)
- `internal/engine/engine.go` - Engine orchestration with sequential execution loop (55 lines)
- `internal/engine/context_test.go` - ExecutionContext tests including concurrency tests (154 lines, 10 test cases)
- `internal/engine/engine_test.go` - Engine tests verifying sequential execution and isolation (170 lines, 10 test cases)
- `coverage_engine.out` - Test coverage profile (generated)

## QA Results

*This section will be populated by the QA Agent after story completion*
